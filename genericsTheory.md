### 1. В какой версии Java появились параметризованные типы?

**Ответ.**  
К наиболее важным новшествам версии языка J2SE 5 можно отнести появление параметризации (generic) классов и методов,
позволяющей использовать гибкую и в то же время достаточно строгую типизацию, что особенно важно при работе с
коллекциями.  
**Источник.** Java. Методы программирования (авт: Валерий Романчик и Игорь Блинов; год издания: 2015). Стр. 68

### 2. Приведите 2 примера кода: первый без параметризованного типа; второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта.

**Ответ.**

```java
public class Program {
    public static void main(String[] args) {
        Account acc1 = new Account(2334, 5000); // id - число
        int acc1Id = (int) acc1.getId();
        System.out.println(acc1Id);

        Account acc2 = new Account("sid5523", 5000);    // id - строка
        System.out.println(acc2.getId());

        Account acc2 = new Account("2345", 5000);
        int acc2Id = (int) acc2.getId(); // java.lang.ClassCastException
        System.out.println(acc2Id);
    }
}

class Account {
    private Object id;
    private int sum;

    Account(Object id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public Object getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}
```

```java
public class Program {
    public static void main(String[] args) {
        Account<String> acc1 = new Account<String>("2345", 5000);
        String acc1Id = acc1.getId();
        System.out.println(acc1Id);

        Account<Integer> acc2 = new Account<Integer>(2345, 5000);
        Integer acc2Id = acc2.getId();
        System.out.println(acc2Id);
    }
}

class Account<T> {
    private T id;
    private int sum;

    Account(T id, int sum) {
        this.id = id;
        this.sum = sum;
    }

    public T getId() {
        return id;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}
```
С помощью буквы T в определении класса class Account<T> мы указываем, что данный тип T будет использоваться этим
классом. Параметр T в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой
тип.  
Вместо примитивных типов надо использовать классы-обертки.

### 3. Какие типы данных запрещены в качестве параметров классов?

**Ответ.**  
В качестве параметров классов запрещено применять базовые типы.  
**Источник.** Java. Методы программирования (авт: Валерий Романчик и Игорь Блинов; год издания: 2015). Стр. 68

### 4. Дан код:
```java
class Gen<T1, T2 extends Number, T3 extends Object> {
…
}
```
### Какие типы можно использовать в качестве аргументов T1, T2, T3?

**Ответ.**  
Такая запись говорит о том, что в качестве типа Т1 разрешено применять любые ссылочные типы. В качестве типа Т2 
допустимо использовать подклассы класса Number, а в качестве параметра T3 - любой тип.

### 5. Дан код:
```java
class Gen1<T> { … }
class Gen2<T extends Object> { … }
class Runner {
    private final static Gen1<Object> g11 = new Gen1<>();
    private final static Gen1 g12 = new Gen1();
    private final static Gen2<Object> g21 = new Gen2<>();
    private final static Gen2 g22 = new Gen2();
...
}
```
### 1. В чем различие объявления классов Gen1 и Gen2?
### 2. Есть ли преимущество в объявлении g11 по сравнению с g12? Обоснуйте ответ.
### 3. Есть ли преимущество в объявлении g21 по сравнению с g12? Обоснуйте ответ.
### 4. В каком случае используется второй способ (g12, g22)?

**Ответ.**  

1.В большинстве случаев объявление классов Gen1 и Gen2 является синонимами.  
2-3. Преимущество заключается в том, что использую параметризацию можно при создании объекта со ссылкой g11 создать более
   типизированный объект, используя вместо <Object> какой-либо параметр, иначе преимущества нет, тк происходит стирание при
компиляции и для объектов параметризированными классом Object можно вызвать только методы класса Object.   
4.Когда в классах отсутствует параметризация.

### 6. Дан код:
```java
class SubInfo extends Info { … }
class Gen1<T> { … }
class Gen2<T extends Info> { … }
```
### 1. Является ли декларация Gen1<Info> подклассом Gen2<Info>?
### 2. Является ли декларация Gen1<SubInfo> подклассом Gen1<Info>?
### 3. Является ли декларация Gen2<SubInfo> подклассом Gen2<Info>?

**Ответ.**

1-3. Не является.

### 7. Почему нельзя вызвать конструктор generic-типа?

**Ответ.**  

Обобщения проверяются во время компиляции на правильность типов. Затем информация об универсальном типе удаляется в
процессе, называемом стиранием типа. В результате стирания типа параметры типа не могут быть определены во время
выполнения. Следовательно, создание экземпляра класса Java параметризованного типа невозможно, поскольку для создания
экземпляра требуется вызов конструктора, который недоступен, если тип неизвестен.  
**Источник.** <https://stackoverflow.com/questions/9366121/calling-constructor-of-a-generic-type>

### 8. Почему нельзя создать generic-поле? Почему статический метод не может иметь generic-параметр?

**Ответ.**  
 
Нельзя использовать параметры универсального типа класса в статических методах или статических полях. Параметры типа
класса относятся только к методам экземпляра и полям экземпляра. Для статических полей и статических методов они
являются общими для всех экземпляров класса, даже для экземпляров параметров разных типов поэтому, очевидно, они не
могут зависеть от конкретного параметра типа.  
**Источник.** <https://stackoverflow.com/questions/936377/static-method-in-a-generic-class>

### 9. Предложите более эффективную запись данного кода:
```java
<T> void make1(Gen<T extends Object> gen){ … }
<T, S extends T> void make2(Info<T> info1,Info<S> info2){ … }
```
**Ответ.**
```java
void make1(Gen<T> gen){…}
<T> void make2(Info<Т> info1, Info<? extends T>info2) {…}
```

### 10. Дан код:
```java
class Info {
    public <T1> Info() {…}
    public <T2> Info(T2 t2) {…}
    public <T1> void make1(T1 t1) {…}
    public <T3> void make2() {…}
}
```

### Создайте какой-либо экземпляр класса Info
### 1. конструктором без аргументов,
### 2. конструктором с аргументом.
### 3. Синтаксически правильно вызовите методы make1() и make2().

**Ответ.**

1. Info<T1> inf = new <T1>Info();
2. Info inf = new Info(new T());
3. inf.make1(), inf.<T3>make2(); 

### 11. Поясните данный код:
`static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)`  

**Ответ.**   
Статический метод, который возвращает максимальный элемент из данной коллекции. Метод принимает в качестве параметра
коллекцию элементы которой имеют тип Т и производные от этого типа.  
`<T extends Object & Comparable<? super T>>` - это приведет к тому, что T станет стираемым объектом.
