###1 Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?

**Ответ.**  
На верхнем уровне — `public` или `package-private` (без явного модификатора).   
**Источник.**<https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html>

###2 Что является членами класса?  

**Ответ.**  
Класс содержит переменные и методы, которые называются элементами класса, членами класса.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/>

###3 Что еще можно определить в классе кроме членов?

**Ответ.**   
Поля, конструкторы, необходимые импорты и пакеты, которые используются в классе.

###4 Какие уровни доступа есть у членов класса?  

**Ответ.**  
Уровень доступа может быть одним из следующих:
* `public` (общедоступный);
* `protected` (защищенный);
* `default` (также называемый пакетным доступом);
* `private` (закрытый).
Член класса имеет пакетный доступ или доступ по умолчанию, когда для него не задан ни один модификатор.  
**Источник.**<https://it.rfei.ru/course/~VGLJ/~703/~i5yxZP>

###5 Какие модификаторы необходимы для определения константы: класса, экземпляра класса?  

**Ответ.**
Для опрделения константы класса необходио сочетание таких ключевых слов как `static` и `final`(все объекты созданные в данном классе видят это значение, оно не может быть модифицировано), 
а для опрделения константы объекта - `final`(инициализяция может производиться в конструкторе, в дальнейшем значение не может быть модифицировно).

###6 Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:  
```
class SomeClass {
private int a;
private final int b;
private static int c;
private static final int D;
}
```
###Как можно назвать данные поля в зависимости от комбинации модификаторов `static` и `final`?  

**Ответ.**
`private int a` : поле класса, инициализация происходит в конструкторе, при создании объекта класса, может быть модифицировано.
`private final int b`: константа экземпляра, не инициализируется в рамках своей декларации, инициализация переносится в конструктор, может изменяться.
`private static int c` : статическая переменная класса, является общая для класса и могут использоваться без создания дбъектов класса.
`private static final int D` : все объекты созданные в данном классе видят это значение, оно не может быть модифицировано.

###7 Может ли класс не иметь ни одного конструктора? Почему?

**Ответ.**  
Класс может не иметь ни одного конструктора. Такие классы называются абстрактные.Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, 
но в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. 
А производные классы уже реализуют этот функционал.  
**Источник.**<https://metanit.com/java/tutorial/3.6.php>

###8 Перечислите отличия конструктора от метода.

**Ответ.**  
Конструктор - это член класса, который используется для создания объектов класса. Конструктор имеет такое же название как и класс,
но не имеет возвращаемого значения. Конструктор вызывается в месте выполнения оператора `new`. Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса.  
**Источник.**<http://www.quizful.net/>

###9 Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?

**Ответ.**  
Для этого применяется конструкция `this()`, которое вызывает один конструктор из другого этого же класса.  
**Источник.**<https://javarush.ru/groups/posts/793-vihzov-konstruktora-iz-konstruktora>

###10 Как и в каком месте можно вызвать конструктор суперкласса?

**Ответ.**  
Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов осуществляется с помощью ключевого слова `super`. 
Вызов конструктора суперкласса должен быть осуществлен в теле конструктора подкласса первым.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/keyword-super>

###11 Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?

**Ответ.**  
Такая конструкция называется конструктором без параметров, который инициализирует все элементы. 
Конструктор без параметров может объявляться в классе явным образом или генерироваться автоматически.  
**Источник.**<https://www.bestprog.net/>

###12 Можно ли одновременно использовать конструкции `this()` и `super()` в одном и том же конструкторе? Обоснуйте ответ.

**Ответ.**  
`this` и `super` - это два специальных ключевых слова в `Java`, которые представляют соответственно текущий экземпляр класса и его суперкласса. `this` представляет текущий экземпляр класса, в то время как `super` - текущий экземпляр родительского класса.
И `this`, и `super` могут использоваться внутри конструкторов для вызова других конструкторов по цепочке, нпр., `this()` и `super()` вызывают конструктор без аргументов наследующего и родительского классов соответственно.

###13 Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?

**Ответ.**  
Это нужно, когда объект создается функцией-фабрикой (статической) того же класса. 
Часто, после создания объекта необходимо вызвать какой-либо его метод (например, для инициализации, которая не может быть выполнена в конструкторе), 
без вызова которого объектом нельзя пользоваться.  
**Источник.**<https://ru.stackoverflow.com>

###14 Какие модификаторы может иметь конструктор?

**Ответ.**  
Конструктор допускает такие можификаторы как `public`, `protected`, `private` или без модификатора.
Конструктор не может иметь модификаторов `abstract`, `final`, `native`, `static` или `synchronized`.  
**Источник.**<https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15>

###15 Конструктор принадлежит классу или экземпляру класса?

**Ответ.**  
Конуструктор вызывается всегда при создании экземпляра класса, поэтому конструктор принадлежит экземпляру класса.  
**Источник.**<https://topjava.ru>

###16 Можно ли наследовать конструктор? Если да, то приведите примеры.

**Ответ.**  
В Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.**<http://proglang.su/java/inheritance>

###17 Какой тип возвращаемого конструктором значения?

**Ответ.**  
Конструкторы не имеют возвращаемого типа. Это объясняется тем, 
что неявно заданным возвращаемым типом конструктора класса является тип самого класса.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/konstruktori>

###18 Дан класс.
```
class Null {
//фрагмент 1
Null Null() {
return null;
}
//фрагмент 2
Null() {
return null;
}
}
```
###В каком фрагменте ошибка компиляции? Удалите этот фрагмент полностью. Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.

**Ответ.**  
Ошибка во втором фрагменте, т.к. конструкторы не имеют возвращаемого типа. В первом фрагменте определен метод, 
но с большой буквы, что не соответствует `code convection`.
```
class Null {
// фрагмент 1
Null Null() {
return null;
}
// фрагмент 2
	Null() {
	}
}
```

###19 Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?

**Ответ.**  
Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, 
а по синтаксису конструктор похож на метод без возвращаемого значения. Таким образом транслятор по синтаксису определяет где метод, а где конструктор.

###20 Дан класс.
```
class Name {
String name;
Name() {
this(makeRandomName());
}
Name(String name) {
super();
this.name = name;
}
String makeRandomName() {
int k = (int) (Math.random() * 3);
String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
return name;
}
public String toString() {
return name;
}
public static void main(String[] args) {
System.out.println(new Name());
}
}
```
Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод `makeRandomName()`обязательно.

**Ответ.**  
Метод `makeRandomName()` принадлежит объекту 'Name' а не классу и поэтому конструктор не может инициализировать данный метод.
Поэтому одно из решений сделать метод `makeRandomName()` статическим, который будет доступен всем экземплярам класса.   
Третий вариант: метод `toString()` возвращает метод `makeRandomName()`.
```
class Name {
String name;
Name() {
this(makeRandomName());
}
Name(String name) {
super();
this.name = name;
}
String makeRandomName() {
int k = (int) (Math.random() * 3);
String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
return name;
}
public String toString() {
return makeRandomName();
}
public static void main(String[] args) {
System.out.println(new Name());
}
}
```

###21 Дан класс.
```
class Int {
int i;
void inc(Int param) {
//param = new Int();
param.i++;
}
public static void main(String[] args) {
Int obj = new Int();
obj.inc(obj);
System.out.println(obj.i);
}
}
```
###Изменится ли результат, если убрать комментарий?  Объясните, почему?

**Ответ.**  
Результат будет разный

###22 В чем смысл конструкции this? Перечислите случаи, когда используется конструкция `this`. В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

**Ответ.**  
Каждому методу (не статическому) при вызове в качестве параметра передаётся ссылка на объект, в котором находится и вызывается данный метод. Для того, чтобы обратиться к объ-екту внутри метода используется неявная ссылка this. Начиная с JDK 8 ссылку можно явно передавать в качестве первого параметра метода. Это сделано для возможности аннотиро-вать.
В статических методах нет ссылки this т.к. эти методы принадлежат классу. К нему можно обратиться по имени класса.

###23 Можно ли присвоить `null` ссылочной переменной `this`?

**Ответ.**  
Нельзя. Если используется `this`, то это означает что, мы находимся в экземпляре и объект существует.

###24 Перечислите случаи, когда используется статический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?

**Ответ.**  
Статические блоки инициализации вызываются всего 1 раз при первой загрузке класса. Используются для инициализации статических
полей класса. Можно не использовать блок и инициализировать сразу, либо в конструкторе класса.  
**Источник.**<https://habr.com/ru/post/133237/>

###25 Перечислите случаи, когда используется логический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?

**Ответ.**  
Логические блоки чаще всего используются в качестве инициализаторов полей, 
но могут содержать вызовы методов и обращения к полям текущего класса.
Также можно инициализировать поля анонимных классов, которые не имеют конструкторов, с помощью логических блоков можно
инициализировать коллекцию:
```
Map<String, String> map = new HashMap<String, String>() {{
put("паук",  "арахнид");
put("птица", "архозавр");
put("кит",   "зверь");
}};
```
**Источник.**<https://habr.com/ru/post/133237/>

###26 Что входит в сигнатуру метода?

**Ответ.**  
Сигнатура метода — это имя метода плюс параметры (причем порядок параметров имеет значение). 
В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.  
**Источник.**<https://javarush.ru/groups/posts/1249-signatura-metoda>

###27 Что значит ключевое слово `native`?

**Ответ.**  
Модификатор native указывает на то, что метод написан не на Java. Методы,
помеченные native, можно переопределять обычными методами в подклассах.
Тело нативного метода должно заканчиваться на `;` как в абстрактных методах,
идентифицируя то, что реализация опущена. 
```
package java.lang;
public class Object {
…
protected native Object clone() throws CloneNotSupportedException;
…
}
```

###28 Дан код.
```
public class BusinessTrip {
…
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
```
###Есть ли в нем семантическая ошибка? Если да, то обоснуйте.

**Ответ.**  
Имеется семантическая ошибка: 
`return (value / 100) + "." + ((value / 10 % 10) + (value % 10));`


###29 Дан код.
```
public class Utility {
private Utility() {
}
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
```
###Есть ли в нем семантическая ошибка? Если да, то предложите альтернативные варианты.

**Ответ.**  


###30 К каким данным можно обратиться в статическом методе?

**Ответ.**  
Если метод статичный — он принадлежит классу. Поэтому можно обращаться к статическому методу или полю, используя имя класса.

###31 Почему нельзя объявить статическое поле внутри метода?

**Ответ.**  
Обычные методы принадлежат конкретному экземпляру класса, и имеют неявную ссылку `this` на него, а статические поля
принадлежат классу, поэтому нельзя объявить статическое поле внутри метода.

###32 Перечислите, какой код в классе можно выполнить до создания объекта.

**Ответ.**   
До создания объекта можно выполнить поля класса и их инциализацию, конструкторы (с параметрами, по умолчанию), методы.  
**Источник.**<https://metanit.com/java/tutorial/3.1.php>

###33 В чем различие между объектом и экземпляром класса?

**Ответ.**  
Объект в Java — это физическое воплощение класса. Он занимает память и имеет элементы данных, которым могут быть присвоены значения.
Если подумать, мы видим множество отношений класса и объекта в реальном мире. Объект — это любая переменная, которая может быть объявлена с указанным типом класса.
Экземпляр в Java очень похож на объект. Это физическое воплощение, оно занимает память и имеет элементы данных, которым можно присваивать значения.
С точки зрения языка Java экземпляр — это любая переменная, которая может быть объявлена с указанным типом класса и назначена определенным значениям для элементов данных.  
**Источник.**<https://study.com/academy/lesson/difference-between-object-instance-in-java.html>

###34 Назовите три этапа создания экземпляра класса.

**Ответ.**  
* Декларация. Декларирование переменной типа класса с уникальным именем.
* Инстанциация. Создание нового объекта с использованием ключевого слова 'new'.
* Инициализация. Вызов конструкторов, который идёт после ключевого слова 'new'.
**Источник.**<https://proselyte.net/tutorials/java-core/classes-and-objects/>

###35 Охарактеризуйте отношение композиции между классами? Как оно реализуется?

**Ответ.**  
Отношения HAS-A можно описать в коде, используя механизм композиции.
Композиция — более строгий тип связи. При использовании композиции объект не только является частью какого-то объекта,
но и не может принадлежать другому объекту того же типа.Самый простой пример — двигатель автомобиля.
Двигатель является частью автомобиля, но не может быть частью другого автомобиля.
Композиция в Java достигается за счет использования переменных экземпляра, который ссылается на другие объекты.
**Источник.**<https://javarush.ru/groups/posts/1967-otnoshenija-mezhdu-klassami-nasledovanie-kompozicija-i-agregirovanie->

###36 Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа. Предложите способы и подтвердите примерами.

**Ответ.**  
Вернуть массив из метода:
```
double[]getCoordinatesArr(){
double[]coordinates = new double[2];
coordinates[0] = 10;
coorinates[1] = 12;
return coordinates;
}
```

###37 Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов. Предложите способы и подтвердите примерами.

**Ответ.**  
Также использовать массив, но использовать общий родительский тип в качестве типа массива:
```
Number[] getCoordinatesNumberArray() {
  
    Number[] coordinates = new Number[2];

    coordinates[0] = 10;   // Integer
    coordinates[1] = 12.5; // Double
  
    return coordinates;
}
```
Использование классов контейнеров:
```
public class Struct {
    private int a;
    private double b;
    public Struct(int a, double b){
        this.setA(a);
        this.setB(b);
    }
    public int getA() {
        return a;
    }
    public void setA(int a) {
        this.a = a;
    }
    public int getB() {
        return b;
    }
    public void setB(int b) {
        this.b = b;
    }
}
return new Struct(x1, x2);
```
Использование коллекций:
```
List getCoordinatesList() {
  
    List coordinates = new ArrayList<>();
  
    coordinates.add(10);  // Integer
    coordinates.add(12.5);  // Double
  
    return coordinates;
}
```

###38 Что такое иммутабельный объект?
###Опишите 2 способа создания иммутабельных объектов. Подсказка. Способ 1 - класс материала в `classes2`.  Какой альтернативный? Подсказка - ключевое слово `final` для полей не использовать. Создайте иммутабельный класс для вещества по альтернативному способу.

**Ответ.**  
Иммутабельный (неизменяемый, immutable) объект — это объект, который после инициализации не может изменить свое состояние.
Первый способ: создать поля класса `final`.
Второй способ: создать `final` класс, в котором все поля `private`, не должно быть сеттеров, конструкторы должны быть переименованы.

###39 Даны 2 класса.
```
final class Material {
private final String name;
private final double density;
...
}
class Runner {
private static void printMaterial(final Material material) {
System.out.println(material);
}
public static void main(String[] args) {
Material steel = new Material("steel",7850);
printMaterial(steel);
}
}
```
###В методе `printMaterial()` по ссылке `material` создается новый объект или имеется доступ к объекту `new Material("steel",7850)`? Какой пример можно использовать для обоснования ответа?

**Ответ.**
**Источник.**<>

###40 Класс для комплексного числа содержит два поля:
```
class Complex {
private double re;
private double im;
…
}
```
###Реализуйте в данном классе методы: `plus()` для операции + и `add()` для `+=`. Приведите пример использования каждого метода. Реализуйте эти же методы при условии, что класс Complex является иммутабельным.

**Ответ.**
**Источник.**<>

###41 Для чего предназначен метод `toString()`? В каких случаях он вызывается?

**Ответ.**  
`toString()` метод в Java используется для предоставления ясной и достаточной информации об объекте (`Object`) в удобном для человека виде.
Вызывается, когда объект должен быть представлен в строковом контексте или когда объект участвует в выражении, где ожидается строковое значение.

###42 Как реализован метод `toString()` в классе `Object`?

**Ответ.**  
Реализация в классе `Object`: `return getClass().getName() + "@" + Integer.toHexString(hashCode())`
**Источник.**<https://javarush.ru/quests/lectures/questmultithreading.level01.lecture03>

###43 Для чего предназначен метод `equals()`?
В каких случаях он вызывается?

**Ответ.**  
Метод `equals()` — сравнивает строку с указанным объектом. Результатом является значение `true` только в том случае,
если аргумент не равен `null` и является строковым объектом `(String)`, который представляет ту же последовательность символов как и этот объект.
`equals()` также используется для обеспечения хранения только уникальных объектов в HashSet и других Set реализациях,
а также в любых других случаях, когда нужно сравнивать объекты.  
**Источник.**<https://javarush.ru/quests/lectures/questmultithreading.level01.lecture03>

###44 Как реализован метод `equals()` в классе `Object`?

**Ответ.**  
```
public boolean equals(Object obj) {
        return (this == obj);
}
```
**Источник.**<https://habr.com/ru/company/otus/blog/443710/>

###45 В чем различие между методом `equals()` и операции `==`? В каких случаях применение метода `equals()` и операции `==` эквивалентно?

**Ответ.**  
Метод equals сравнивает символы из объекта типа String, а операция == - две ссылки на объекты, определяя ссылаются ли они на один и тот же экземпляр.
Метод `equals()` и операция `==` дают одинаковый результат в том случае, если метод `equals()` не переопрделен, то обе операции будут сравнивать ссылки на объект.

###46 `Eclipse` в стандартной конфигурации генерирует начало метода `equals()` следующим образом:
```
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
```
###С чем связаны данные проверки, которые кажутся лишними?

**Ответ.**  
Для выполнения качественного и эффективного сравнения необходимо выполнить сравнение объекта с самим собой.
Ведь если мы сравниваем объект с самим собой, зачем нам выполнять лишние проверки и сравнивать поля объекта.
Это проверки помогают понять, не является ли объект null и сравниваем ли мы объекты одинаковых классов.
Если мы изначально сравниваем два null объекта, то первая проверка вернёт нам true, а значит ко второму шагу объект точно не должен быть null.
**Источник.**<https://training.by/#!/News/339?lang=ru>

###47 Что такое `garbage collection`?

**Ответ.**  
Сборка мусора Java — это процесс, с помощью которого программы Java выполняют автоматическое управление памятью. 
Java-программы компилируются в байт-код, который можно запускать на виртуальной машине Java или сокращенно JVM. 
Когда Java-программы запускаются на JVM, объекты создаются в куче, которая представляет собой часть памяти, выделенную для программы. 
Со временем некоторые объекты перестанут быть нужными. Сборщик мусора находит эти неиспользуемые объекты и удаляет их, освобождая память.  
**Источник.**<https://stackify.com/what-is-java-garbage-collection/#:~:text=Java%20garbage%20collection%20is%20the,memory%20dedicated%20to%20the%20program.>

###48 Перечислите случаи, когда `JVM` отдает управление на `garbage collector`.

**Ответ.**
**Источник.**<>

###49 Как сделать так, чтобы `JVM` сразу перешла в режим сборки мусора?

**Ответ.**
**Источник.**<>

###50 Гарантирует ли garbage `collector`, что приложение в любом случае не будет иметь проблемы с недостатком памяти? Обоснуйте ответ.

**Ответ.**
**Источник.**<>

###51 Для чего предназначен метод `finalize()`? Какой недостаток у метода?

**Ответ.**
**Источник.**<>

###52 Для чего предназначены оболочечные классы? Как они называются на инглише?

**Ответ.**
Классы-оболочки `Java` являются объектным представлением восьми примитивных типов в `Java`. 
Все классы-оболочки в `Java` являются неизменными и `final`. Классы-оболочки позволяют работать с примитивными типами, как с объектами, что упрощает работу.  
Название классов-оболочек (`wrapper)`: `Integer`, `Byte`, `Short`, `Long`, `Float`, `Double`, `Character`, `Boolean`.

###53 В чем преимущество примитивных типов перед соответствующими оболочечными классами?

**Ответ.**
**Источник.**<>

###54 Что такое `autoboxing` и `unboxing`?

**Ответ.**
**Источник.**<>

###55 Дан код:
```
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.
```

**Ответ.**
**Источник.**<>

###56 Дан корректный раннер-класс. Будет ли ошибка компиляции, если удалить модификатор `static` из сигнатуры метода `main()`? Обоснуйте ответ. Что произойдет, если отправить на выполнение измененный класс?

**Ответ.**
**Источник.**<>

###57 Дан класс.
```
class Runner {
public static void main(String[] args) {
System.out.println("Hello, world!");
}
}
```
###Запрещается изменять синий код, т.е. метод `main()`. Добавить код в класс `Runner`, так чтобы в результате запуска этого класса из под `JVM` в консоли был следующий результат:
```
I am java.
Hello, world!
```

**Ответ.**
**Источник.**<>

###58 Бонусное задание 1 (необязательное) В задаче classes3 имеются два константных поля в классе покупки. Им сразу присваиваются значения по умолчанию. Например.  
```
public class Purchase {
public final static String PRODUCT_NAME = "milk";
public final static int PRICE = 120;
...
}
```
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам `PRODUCT_NAME` и `PRICE` значения по умолчанию.
Для этого же примера начало класса должно быть таким:  
```
public class Purchase {
private static final String PRODUCT_NAME;
private static final int PRICE;
public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
private static final String DEFAULT_PRODUCT_NAME = "milk";
private static final int DEFAULT_PRICE = 120;
```

**Ответ.**
**Источник.**<>
