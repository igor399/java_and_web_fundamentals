### 1 Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?

**Ответ.**  
На верхнем уровне — `public` или `package-private` (без явного модификатора).   
**Источник.**<https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html>

### 2 Что является членами класса?

**Ответ.**  
Класс содержит переменные(поля) и методы, которые называются элементами класса, членами класса.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/>

### 3 Что еще можно определить в классе кроме членов?

**Ответ.**   
Конструкторы, инициализаторы, необходимые импорты и пакеты, которые используются в классе.  
**Источник.**<https://java-online.ru/java-class.xhtml>

### 4 Какие уровни доступа есть у членов класса?

**Ответ.**  
Существует три модификатора доступа: public, private и protected и четыре уровня доступа:

1) `public` (открытый) - когда член объявляется с модификатором доступа public, он становится доступным из любого
   другого кода.
2) `private` (закрытый) - когда член класса объявляется с модификатором доступа private, он доступен только другим
   членам этого же класса.
3) `protected` (защищенный) - применяется только при наследовании.
4) Уровень доступа, предоставляемый по умолчанию - в отсутствие модификатора доступа по умолчанию член класса считается
   открытым в своем пакете, но недоступным для кода, находящегося за пределами этого пакета.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/upravlenie-dostupom>

### 5 Какие модификаторы необходимы для определения константы: класса, экземпляра класса?

**Ответ.**
1) `public final int MIN_TAX = 8` (пример константы экземпляра класса);
2) `public final static int PURCHASE_TAX = 6` (пример константы класса).  
**Источник.** Java. Методы программирования (авт: Валерий Романчик и Игорь Блинов; год издания: 2015). Стр 55

### 6 Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:

```java
class SomeClass {
    private int a;
    private final int b;
    private static int c;
    private static final int D;
}
```

### Как можно назвать данные поля в зависимости от комбинации модификаторов `static` и `final`?

**Ответ.**
`private int a` : поле класса, инициализация происходит в конструкторе, при создании объекта класса, может быть
модифицировано.
`private final int b`: константа экземпляра, не инициализируется в рамках своей декларации, инициализация переносится в
конструктор.
`private static int c` : статическая переменная класса, является общая для класса и могут использоваться без создания
объектов класса.
`private static final int D` : все объекты созданные в данном классе видят это значение, оно не может быть
модифицировано.  
**Источник.** Java. Методы программирования (авт: Валерий Романчик и Игорь Блинов; год издания: 2015). Стр 55

### 7 Может ли класс не иметь ни одного конструктора? Почему?

**Ответ.**  
Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (
`default constructor`). Этот конструктор пустой и не делает ничего, кроме вызова конструктора суперкласса. Т.е. если
написать: `public class Example { }` то это эквивалентно написанию: `public class Example { Example () { super ; } }` В
данном случае явно класса предка не указано, а по умолчанию все классы `Java` наследуют класс `Object` поэтому
вызывается конструктор класса.  
**Источник.**<https://mosgensovet.ru/utilities/dlya-chego-nuzhny-konstruktory-v-java-konstruktory-konstruktory-po-umolchani>

### 8 Перечислите отличия конструктора от метода.

**Ответ.**  
Конструктор должен создавать экземпляр класса. Вместо этого функция метода заключается в выполнении кода Java. У
конструкторов и методов есть три удобных отличия: модификаторы, возвращаемые значения и именование. Как и методы,
конструкторы можно оформить любым доступом: `public`, `protected`, `private` или по умолчанию. В отличие от метода,
конструктор не может иметь следующие свойства, не связанные с доступом: `abstract`, `final`, `native`, `static`, или
же `synchronized`. Тип возвращаемые значения также очень важен. Методы могут возвращать любой тип значения или не
возвращать значение (`void`), конструктор же не имеет возвращаемого значения и не нуждается в `void`.  
Конструктор использует то же имя, что и класс, но метод другой. По соглашению, методы обычно начинаются со строчных
букв, а конструкторы - с прописных. Конструктор обычно является существительным, потому что он совпадает с именем
класса; и метод обычно ближе к глаголу, потому что он описывает операцию.

* Имя конструктора должно совпадать с именем класса
* Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по
  умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса
* Конструктор нельзя наследовать или переопределить в подклассе
* Конструктор не имеет возвращаемого типа
* В конструкторе допускается оператор return, но только пустой, без всякого возвращаемого значения

**Источник.**<https://russianblogs.com/article/51341430106/>

### 9 Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?

**Ответ.**  
При необходимости вызова одного конструктора из другого мы можем сделать это используя this()
и передав те параметры, которые нужны вызываемому конструктору. Есть условия, которые необходимо соблюдать в таком
случае, а именно:

1) вызов this() должен быть первой операцией;
2) второй раз вызывать в конструкторе this() запрещено  
**Источник.**<http://javaway.info/kak-vyzvat-odin-konstruktor-iz-drugogo/>

### 10 Как и в каком месте можно вызвать конструктор суперкласса?

**Ответ.**  
Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов
осуществляется с помощью ключевого слова `super`. Вызов конструктора суперкласса должен быть осуществлен в теле
конструктора подкласса первым.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/keyword-super>

### 11 Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?

**Ответ.**  
Такая конструкция называется конструктором без параметров, который инициализирует все элементы. Конструктор без
параметров может объявляться в классе явным образом или генерироваться автоматически. Если super() не используется, то
сначала будет выполнен конструктор по умолчанию (без параметров) каждого суперкласса, начиная с базового класса.  
**Источник.**<https://www.bestprog.net/ru/2018/09/07/constructors-default-constructors-calling-class-constructors-from-other-constructors_ru/>

### 12 Можно ли одновременно использовать конструкции `this()` и `super()` в одном и том же конструкторе? Обоснуйте ответ.

**Ответ.**  
Внутри конструктора `this()` и `super()` должны стоять выше всех других выражений, в самом начале, иначе компилятор
выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и `this()`, и `super()`
.  
**Источник.**<https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java>

### 13 Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?

**Ответ.**  
Это нужно, когда объект создается функцией-фабрикой (статической) того же класса. Часто, после создания объекта
необходимо вызвать какой-либо его метод (например, для инициализации, которая не может быть выполнена в конструкторе),
без вызова которого объектом нельзя пользоваться.  
Также приватный конструктор запрещает создание экземпляра класса вне методов самого класса, например, что гарантировать
существование только одного объекта определённого класса, предположим какого-то ресурса, например БД. Паттерн
Singleton (Одиночка).  
**Источник.**<https://ru.stackoverflow.com/questions/824210/private-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80>

### 14 Какие модификаторы может иметь конструктор?

**Ответ.**  
Конструктор допускает такие модификаторы как `public`, `protected`, `private` или без модификатора. Конструктор не может
иметь модификаторов `abstract`, `final`, `native`, `static` или `synchronized`.  
**Источник.**<https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15>

### 15 Конструктор принадлежит классу или экземпляру класса?

**Ответ.**  
Конструктор вызывается всегда при создании экземпляра класса, поэтому конструктор принадлежит экземпляру класса.  
**Источник.**<https://topjava.ru/blog/rukovodstvo-po-konstruktoram-v-java>

### 16 Можно ли наследовать конструктор? Если да, то приведите примеры.

**Ответ.**  
В Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть
вызван из подкласса.  
**Источник.**<http://proglang.su/java/inheritance>

### 17 Какой тип возвращаемого конструктором значения?

**Ответ.**  
Конструкторы не имеют возвращаемого типа. Это объясняется тем, что неявно заданным возвращаемым типом конструктора
класса является тип самого класса.  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/konstruktori>

### 18 Дан класс.

```java
class Null {
    //фрагмент 1
    Null Null() {
        return null;
    }

    //фрагмент 2
    Null() {
        return null;
    }
}
```

### В каком фрагменте ошибка компиляции? Удалите этот фрагмент полностью. Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.

**Ответ.**  
Ошибка во втором фрагменте, т.к. конструкторы не имеют возвращаемого типа. В первом фрагменте определен метод, но с
большой буквы, что не соответствует `code convection`.

```java
class Null {
    // фрагмент 1
    Null Null() {
        return null;
    }

    // фрагмент 2
    Null() {
    }
}
```

### 19 Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?

**Ответ.**  
Методы по Java Convention должны иметь название с маленькой буквы, конструкторы с большой буквы и полностью совпадать с
именем класса в котором он находится. Конструкторы не имеют возвращаемого типа. В то время как методы должны указывать
тип возращаемого элемента (void либо какой-то конкретный).  
**Источник.**<https://www.examclouds.com/ru/java/java-core-russian/konstruktori>

### 20 Дан класс.

```java
class Name {
    String name;

    Name() {
        this(makeRandomName());
    }

    Name(String name) {
        super();
        this.name = name;
    }

    String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[]{"Alpha", "Beta", "Gamma"}[k];
        return name;
    }

    public String toString() {
        return name;
    }

    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
```

Объясните причину ошибки компиляции. Предложите минимум 2 способа исправления ошибки, использовать
метод `makeRandomName()`обязательно.

**Ответ.**  
Возникает ошибка "Cannot reference 'Name.makeRandomName' before supertype constructor has been called". Мы пытаемся
вызвать метод объекта еще до того, как он создан. Для решения этой проблемы мы можем сделать
метод `makeRandomName() static` и в конструкторе прописать `this(Name.makeRandomName())`. Также мы можем сделать
следующее: в конструкторе присваиваем переменной name значение `makeRandomName()`.    
Третий вариант: метод `toString()` возвращает метод `makeRandomName()`.

### 21 Дан класс.

```java
class Int {
    int i;

    void inc(Int param) {
//param = new Int();
        param.i++;
    }

    public static void main(String[] args) {
        Int obj = new Int();
        obj.inc(obj);
        System.out.println(obj.i);
    }
}
```

### Изменится ли результат, если убрать комментарий? Объясните, почему?

**Ответ.**  
Да, изменится. В первом случае результат будет 1, во втором 0. В первом случае метод работает только с одним объектом и
его переменной, поэтому инкрементирование происходит. При раскомментировании строки метод создает дополнительный объект,
в котором происходит увеличение на 1, и после завершения выполнения метода данный объект исчезает в связи с чем,
первоначальный объект остается со своим начальным значением 0 и для него изменений нет.

### 22 В чем смысл конструкции this? Перечислите случаи, когда используется конструкция `this`. В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

**Ответ.**  
Каждому методу (не статическому) при вызове в качестве параметра передаётся ссылка на объект, в котором находится и
вызывается данный метод. Для того, чтобы обратиться к объ-екту внутри метода используется неявная ссылка this. Начиная с
JDK 8 ссылку можно явно передавать в качестве первого параметра метода. Это сделано для возможности аннотировать. В
статических методах нет ссылки this т.к. эти методы принадлежат классу. К нему можно обратиться по имени класса.

1) Используется для дифференцирования между переменными экземпляра и локальными переменными в случае, если у них
   одинаковые имена, в составе конструктора или метода.
2) Используется для вызова конструктора одного типа (параметризованного конструктора либо конструктора по умолчанию) из
   другого в составе класса. Данный процесс также носит название явного вызова конструктора.
3) Если локальные переменные будут иметь отличное от поля название, то this можно опустить
   (name = localName или писать this.name = name).    
**Источник.**<http://proglang.su/java/methods>

### 23 Можно ли присвоить `null` ссылочной переменной `this`?

**Ответ.**  
Нельзя. Если используется `this`, то это означает что, мы находимся в экземпляре и объект существует.

### 24 Перечислите случаи, когда используется статический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?

**Ответ.**  
Статические блоки инициализации вызываются всего 1 раз при первой загрузке класса. Используются для инициализации
статических полей класса. Можно не использовать блок и инициализировать сразу, либо в конструкторе класса.  
**Источник.**<https://habr.com/ru/post/133237/>

### 25 Перечислите случаи, когда используется логический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?

**Ответ.**  
При описании класса могут быть использованы логические блоки. Логическим блоком называется код, заключенный в фигурные
скобки и не принадлежащий ни одному методу текущего класса, Логические блоки чаще всего используются в качестве
инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса. При создании объекта
класса они вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая
последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса. Операции с
полями класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки this,
представляющую собой ссылку на текущий объект.    
Также можно инициализировать поля анонимных классов, которые не имеют конструкторов, с помощью логических блоков можно
инициализировать коллекцию:

```java
Map<String, String> map=new HashMap<String, String>(){{
        put("паук","арахнид");
        put("птица","архозавр");
        put("кит","зверь");
        }};
```

**Источник.**<https://habr.com/ru/post/133237/>

### 26 Что входит в сигнатуру метода?

**Ответ.**  
Сигнатура метода — это имя метода плюс параметры (причем порядок параметров имеет значение). В сигнатуру метода не
входит возвращаемое значение, а также бросаемые им исключения.  
**Источник.**<https://javarush.ru/groups/posts/1249-signatura-metoda>

### 27 Что значит ключевое слово `native`?

**Ответ.**  
Модификатор native указывает на то, что метод написан не на Java. Методы, помеченные native, можно переопределять
обычными методами в подклассах. Тело нативного метода должно заканчиваться на `;` как в абстрактных методах,
идентифицируя то, что реализация опущена.

```java
package java.lang;

public class Object {
…

    protected native Object clone() throws CloneNotSupportedException;
…
}
```

### 28 Дан код.

```java
public class BusinessTrip {
…

    public String bynToStr(int value) {
        return (value / 100) + "." + (value / 10 % 10) + (value % 10);
    }
}
```

### Есть ли в нем семантическая ошибка? Если да, то обоснуйте.

**Ответ.**  
Возвращаемое значение можно упростить до:
`return return String.format("%d.%02d", getRubs(), getCoins());`

### 29 Дан код.

```java
public class Utility {
    private Utility() {
    }

    public String bynToStr(int value) {
        return (value / 100) + "." + (value / 10 % 10) + (value % 10);
    }
}
```

### Есть ли в нем семантическая ошибка? Если да, то предложите альтернативные варианты.

**Ответ.**  
Наименование метода корректно изменить на toByn. К тому же возвращаемое значение можно упростить до
`(value / 100) + "." + (value % 100)`. Для создания объекта также дополнительно нужно создать статический метод, который
должен вернуть экземпляр данного класса. По другому объект не будет создан.

Метод bynToStr(int value) необходимо сделать статическим, т.к. конструктор определен с модификатором доступа private ,
что не дает возможности создать обьект класса Utility для вызова нестатического метода.

### 30 К каким данным можно обратиться в статическом методе?

**Ответ.**  
Cтатические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего
метода все элементы будут инициализированы и будут работать.  
**Источник.**<https://vertex-academy.com/tutorials/ru/modifikator-static-v-java-metody/>

### 31 Почему нельзя объявить статическое поле внутри метода?

**Ответ.**  
В языке Java, если поле объявляется статическим (путем добавления модификатора static), то в независимости от количества
созданных объектов класса — всегда будет существовать только один экземпляр статического поля. Значение такого поля
будет единым и общим для всех объектов класса, содержащих это поле. В то же время, если мы поместим это поле в метод, то
у нас не будет напрямую возможности обратится к данному полю и оно не сможет независимо существовать от объектов.
Обычные методы принадлежат конкретному экземпляру класса, и имеют неявную ссылку `this` на него, а статические поля
принадлежат классу, поэтому нельзя объявить статическое поле внутри метода.  
**Источник.**<https://topjava.ru/blog/rukovodstvo-po-modifikatoru-static-v-java>

### 32 Перечислите, какой код в классе можно выполнить до создания объекта.

**Ответ.**   
Как известно, в Java поля (fields) могут принадлежать классу или объекту. Поля, принадлежащие классу, являются
статическими, а поля, принадлежащие объекту, - нестатическими. Статические поля доступны без создания объекта класса.
Соответственно инициализироваться статические и нестатические поля должны в разное время: одни до создания объекта
класса, а другие после.В некоторых случаях инициализацию неудобно проводить в месте объявления переменной. Например,
если в результате выполнения инициализирующего выражения происходит проверяемое исключение. Или же, если инициализация
производится путем выполнения кода, который не может быть представлен в виде выражения. Для таких случаев в Java
предусмотрен специальный языковой элемент - инициализационный статический блок. Он также выполняется до создания
объекта.   
**Источник.**<http://www.quizful.net/post/java-fields-initialization>

### 33 В чем различие между объектом и экземпляром класса?

**Ответ.**  
Объект в Java — это физическое воплощение класса. Он занимает память и имеет элементы данных, которым могут быть
присвоены значения. Если подумать, мы видим множество отношений класса и объекта в реальном мире. Объект — это любая
переменная, которая может быть объявлена с указанным типом класса. Экземпляр в Java очень похож на объект. Это
физическое воплощение, оно занимает память и имеет элементы данных, которым можно присваивать значения. С точки зрения
языка Java экземпляр — это любая переменная, которая может быть объявлена с указанным типом класса и назначена
определенным значениям для элементов данных.  
**Источник.**<https://study.com/academy/lesson/difference-between-object-instance-in-java.html>

### 34 Назовите три этапа создания экземпляра класса.

**Ответ.**

* Декларация. Декларирование переменной типа класса с уникальным именем.
* Инстанциация. Создание нового объекта с использованием ключевого слова 'new'.
* Инициализация. Вызов конструкторов, который идёт после ключевого слова 'new'.  
**Источник.**<https://proselyte.net/tutorials/java-core/classes-and-objects/>

### 35 Охарактеризуйте отношение композиции между классами? Как оно реализуется?

**Ответ.**  
Отношения HAS-A можно описать в коде, используя механизм композиции. Композиция — более строгий тип связи. При
использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту
того же типа.Самый простой пример — двигатель автомобиля. Двигатель является частью автомобиля, но не может быть частью
другого автомобиля. Композиция в Java достигается за счет использования переменных экземпляра, который ссылается на
другие объекты.  
**Источник.**<https://javarush.ru/groups/posts/1967-otnoshenija-mezhdu-klassami-nasledovanie-kompozicija-i-agregirovanie->

### 36 Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа. Предложите способы и подтвердите примерами.

**Ответ.**  
Вернуть массив из метода:

```java
double[]getCoordinatesArr(){
        double[]coordinates=new double[2];
        coordinates[0]=10;
        coorinates[1]=12;
        return coordinates;
        }
```

### 37 Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов. Предложите способы и подтвердите примерами.

**Ответ.**  
Также использовать массив, но использовать общий родительский тип в качестве типа массива:

```java
Number[]getCoordinatesNumberArray(){
        Number[]coordinates=new Number[2];
        coordinates[0]=10;   // Integer
        coordinates[1]=12.5; // Double
        return coordinates;
        }
```

Использование классов контейнеров:

```java
public class Struct {
    private int a;
    private double b;

    public Struct(int a, double b) {
        this.setA(a);
        this.setB(b);
    }

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }

    public int getB() {
        return b;
    }

    public void setB(int b) {
        this.b = b;
    }
}
return new Struct(x1,x2);
```
Использование коллекций:

```java
List getCoordinatesList(){
        List coordinates=new ArrayList<>();
        coordinates.add(10);  // Integer
        coordinates.add(12.5);  // Double
        return coordinates;
        }
```
C помощью использования параметра метода (массива или коллекции) для получения результата. Пусть метод должен вычислить и
возвратить число разрядов, передаваемого целого числа, и возвратить массив или список, состоящий из цифр этого числа.
Метод, решающий обе проблемы, может быть записан в виде:

```java
  public class MethodAction {
    public int numberParser(int number, int[] numbers) {
        String str = String.valueOf(number);
        int length = str.length();
        for (int i = 0; i < length; ++i) {
            char code = str.charAt(i);
            int n = Character.digit(code, 10);
            numbers[i] = n;
        }
        return length;
    }
}

public class MethodReturnMain {
    public static void main(String[] args) {
        MethodAction method = new MethodAction();
        int num = 739_015_428;
        int[] result = new int[10];
        int length = method.numberParser(num, result);
        System.out.println(length);
        for (int j = 0; j < length; j++) {
            System.out.printf("%d, ", result[j]);
        }
    }
}
```

### 38 Что такое иммутабельный объект?

### Опишите 2 способа создания иммутабельных объектов. Подсказка. Способ 1 - класс материала в `classes2`. Какой альтернативный? Подсказка - ключевое слово `final` для полей не использовать. Создайте иммутабельный класс для вещества по альтернативному способу.

**Ответ.**  
Immutable объекты(с англ. "неизменяемый") - это объект, который не позволяет изменять свои параметры. А если Вы все-же
пытаетесь что-то изменить, то получаете новый объект. Но старый останется прежним. 2 способа создания иммутабельных
объектов: 1) использовать Enum; 2) создать класс с приватными final полями, не создавать сеттеров, класс пометить как
final.   
**Источник.**<https://vertex-academy.com/tutorials/ru/stateless-i-immutable-java/>

### 39 Даны 2 класса.

```java
final class Material {
    private final String name;
    private final double density;
...
}

class Runner {
    private static void printMaterial(final Material material) {
        System.out.println(material);
    }

    public static void main(String[] args) {
        Material steel = new Material("steel", 7850);
        printMaterial(steel);
    }
}
```

### В методе `printMaterial()` по ссылке `material` создается новый объект или имеется доступ к объекту `new Material("steel",7850)`? Какой пример можно использовать для обоснования ответа?

**Ответ.**    
Имеется доступ к объекту `new Material("steel",7850)`. `steel` - это объект и доступ к нему осуществляется по ссылке,
которую мы передали в метод `printMaterial`.

### 40 Класс для комплексного числа содержит два поля:

```java
class Complex {
    private double re;
    private double im;
…
}
```

### Реализуйте в данном классе методы: `plus()` для операции + и `add()` для `+=`. Приведите пример использования каждого метода. Реализуйте эти же методы при условии, что класс Complex является иммутабельным.

**Ответ.**

```java
class Complex {
    private double re;
    private double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public Complex plus(Complex complexNum) {
        return new Complex(complexNum.re + re, complexNum.im + im);
    }

    public void add(Complex complexNum) {
        re += complexNum.re;
        im += complexNum.im;
    }
} 
```

### 41 Для чего предназначен метод `toString()`? В каких случаях он вызывается?

**Ответ.**  
`toString()` метод в Java используется для предоставления ясной и достаточной информации об объекте (`Object`) в удобном
для человека виде. Вызывается, когда объект должен быть представлен в строковом контексте или когда объект участвует в
выражении, где ожидается строковое значение.  
**Источник.**<https://javarush.ru/groups/posts/695-10-podskazok-po-pereopredeleniju-metoda-tostring-v-java-chastjh-1>

### 42 Как реализован метод `toString()` в классе `Object`?

**Ответ.**  
Реализация в классе `Object`: `return getClass().getName() + "@" + Integer.toHexString(hashCode())`
**Источник.**<https://javarush.ru/quests/lectures/questmultithreading.level01.lecture03>

### 43 Для чего предназначен метод `equals()`? В каких случаях он вызывается?

**Ответ.**  
Символ “==” имеет смысл использовать только с примитивами. Что касается объектов, “==” в Java сравнивает только ссылки,
то есть проверяет, равен ли объект самому себе, а это не всегда может быть полезно. Для сравнения объектов в
классе `Object` присутствует метод `equals()`, именно он и должен выполнять сравнение объектов. По умолчанию этот метод
выполняет внутри себя операцию “==”, однако, идея этого метода состоит в том, что он должен быть переопределён для
создаваемых классов.  
**Источник.** <https://training.by/#!/News/339?lang=ru>

### 44 Как реализован метод `equals()` в классе `Object`?

**Ответ.**  
Реализация по умолчанию метода `equals()` в классе `java.lang.Object` сравнивает ссылки на адреса в памяти, которые
хранят переменные, и возвращает `true` только в том случае, если адреса совпадают, другими словами переменные ссылаются
на один и тот же объект.

```java
public boolean equals(Object obj){
        return(this==obj);
        }
```

**Источник.**<https://habr.com/ru/company/otus/blog/443710/>

### 45 В чем различие между методом `equals()` и операции `==`? В каких случаях применение метода `equals()` и операции `==` эквивалентно?

**Ответ.**  
В Java сравнение объектов производится с помощью метода equals() класса Object. Этот метод сравнивает содержимое объектов и
выводит значение типа boolean. Значение true - если содержимое эквивалентно, и false — если нет.
Операция == не рекомендуется для сравнения объектов в Java. Дело в том, что при сравнении объектов, операция == вернет true
лишь в одном случае — когда ссылки указывают на один и тот же объект. В данном случае не учитывается содержимое переменных класса.
При создании пользовательского класса, принято переопределять метод equals() таким образом, что бы учитывались переменные объекта.  
***Источник**<https://www.examclouds.com/java/java-core-russian/method-equals>

### 46 `Eclipse` в стандартной конфигурации генерирует начало метода `equals()` следующим образом:

```java
public boolean equals(Object obj){
        if(this==obj)
        return true;
        if(obj==null)
        return false;
```

### С чем связаны данные проверки, которые кажутся лишними?

**Ответ.**  
Для выполнения качественного и эффективного сравнения необходимо выполнить сравнение объекта с самим собой. Ведь если мы
сравниваем объект с самим собой, зачем нам выполнять лишние проверки и сравнивать поля объекта. Это проверки помогают
понять, не является ли объект null и сравниваем ли мы объекты одинаковых классов. Если мы изначально сравниваем два null
объекта, то первая проверка вернёт нам true, а значит ко второму шагу объект точно не должен быть null.  
**Источник.**<https://training.by/#!/News/339?lang=ru>

### 47 Что такое `garbage collection`?

**Ответ.**  
Сборка мусора Java — это процесс, с помощью которого программы Java выполняют автоматическое управление памятью.
Java-программы компилируются в байт-код, который можно запускать на виртуальной машине Java или сокращенно JVM. Когда
Java-программы запускаются на JVM, объекты создаются в куче, которая представляет собой часть памяти, выделенную для
программы. Со временем некоторые объекты перестанут быть нужными. Сборщик мусора находит эти неиспользуемые объекты и
удаляет их, освобождая память.  
**Источник.**<https://stackify.com/what-is-java-garbage-collection/#:~:text=Java%20garbage%20collection%20is%20the,memory%20dedicated%20to%20the%20program.>

### 48 Перечислите случаи, когда `JVM` отдает управление на `garbage collector`.

**Ответ.**  
Автоматическое освобождение памяти, занимаемой объектом, выполняется с помощью механизма «сборки мусора». Когда никаких
ссылок на объект не существует, т.е. все ссылки на него вышли из области видимости программы, предполагается, что объект
больше не нужен, и память, занятая объектом, может быть освобождена. Сборка мусора» происходит нерегулярно во время
выполнения программы. Форсировать «сборку мусора» невозможно, можно лишь «рекомендовать» выполнить ее вызовом метода
System.gc() или Runtime.getRuntime().gc(), но виртуальная машина выполнит очистку памяти тогда, когда сама посчитает это
удобным. Если память под приложение заканчивается, то вероятность запуска garbage collector возрастает.  
**Источник.** Java From EPAM (авт: Валерий Романчик и Игорь Блинов; год издания: 2020). Стр 145)

### 49 Как сделать так, чтобы `JVM` сразу перешла в режим сборки мусора?

**Ответ.**  
Можно принудительно инициировать вызов `finalize`-методов удаляемых объектов, посредством `System.runFinalization()`. Но
дело в том, что по документации `Java`, это не гарантирует ни начало сборки мусора, ни вызов методов `finalize()`.
`Garbage Collector` сам решает, что и когда ему вызывать. В Java одни объекты ссылаются на другие, и именно с помощью
этой сети ссылок определяется – стоит удалять объект или нет. В Java есть специальные ссылки, которые позволяют влиять
на этот процесс. Для них есть специальные классы-обертки:  
*SoftReference – мягкая ссылка.  
*WeakReference – слабая ссылка.  
*PhantomReference – призрачная ссылка.  
**Источник.**<https://javarush.ru/quests/lectures/questcollections.level04.lecture03>

### 50 Гарантирует ли garbage `collector`, что приложение в любом случае не будет иметь проблемы с недостатком памяти? Обоснуйте ответ.

**Ответ.**  
Нет, не гарантирует. В приложение может быть утечка памяти из-за незакрытых потоков, перекрестные ссылки, которые трудно
отследить gc, изначально недостаток памяти в heap. Все это может сказаться на нашем приложении и garbage collector не
поможет.

### 51 Для чего предназначен метод `finalize()`? Какой недостаток у метода?

**Ответ.**  
Метод `finalize()` вызывается лишь непосредственно перед сборкой "мусора". Метод `finalize()` не вызывается при выходе
объекта из области действия. Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод `finalize()`. И самое
главное - начиная с Java 9 этот метод не рекомендуется к использованию. Метод `finalize` вызывается при первой сборке
мусора следующей за моментом когда ваш объект стал недостижим, то вполне реально, что он не будет вызван вообще, ведь
ваше приложение может закончить свою работу так и не дойдя до этой самой сборки мусора. Спецификация `JVM` не определяет
вопрос многопоточности метода финализации. В `HotSpot` все методы `finalize` будут вызываться последовательно в одном
потоке `Finalizer`. Переопределение метода `finalize` значительно удлиняет время жизни объекта после смерти, так как он
будет удален из памяти не раньше второй сборки мусора. Во время выполнения метода `finalize` вы можете восстановить
ссылку на объект, например, поместив ее в какой-нибудь статический контекст, тем самым вы воскресите объект. Опасность
такого маневра заключается в том, что второй раз метод `finalize` у данного объекта уже никогда вызван не будет. Одна из
самых неприятных проблем возникающих при использовании метода `finalize` — это реордеринг. Представьте, что у вас есть
два объекта с переопределенным методом `finalize`, один из которых ссылается на другой. Так вот, если эти объекты стали
недостижимы, то порядок вызова методов финализации произойдет в случайном порядке. Таким образом, у вас будет
потенциальная опасность вызвать какой-нибудь метод на уже финализированном объекте из метода `finalize` другого объекта
и получить ошибку. Причем проблема будет возникать не на каждом объекте, что добавит головной боли при отладке. Согласно
Джошуа Блоху, автору знаменитой книги «Effective Java: Programming Language Guide», для объектов с переопределенным
методом `finalize` аллокация и сборка может происходить в 430 раз медленнее, чем у обычного объекта.  
Любые исключения выброшенные в теле метода будут проигнорированы. Надо не забыть в конце метода
вызвать `super.finalize ()`. А учитывая предыдущий пункт, сделать это необходимо в блоке `finally`.   
**Источник.**<https://habr.com/ru/post/130370/>

### 52 Для чего предназначены оболочечные классы? Как они называются на инглише?

**Ответ.**  
Классы-оболочки `Java` являются объектным представлением восьми примитивных типов в `Java`. Все классы-оболочки в `Java`
являются неизменными и `final`. Классы-оболочки позволяют работать с примитивными типами, как с объектами, что упрощает
работу.  
Название классов-оболочек (`wrapper)`: `Integer`, `Byte`, `Short`, `Long`, `Float`, `Double`, `Character`, `Boolean`.  
**Источник**<https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/>

### 53 В чем преимущество примитивных типов перед соответствующими оболочечными классами?

**Ответ.**  
В том, что не происходит процесс автоупаковки и автораспаковки, который влияет на производительность программы.  
**Источник.**<https://javarush.ru/groups/posts/706-avtoupakovka-i-raspakovka-v-java>

### 54 Что такое `autoboxing` и `unboxing`?

**Ответ.**  
`autoboxing` - это функция преобразования примитивных типов в объектные.
`unboxing` - процесс преобразования объектов в соответствующие им примитивные типы.  
**Источник.**<https://javarush.ru/groups/posts/706-avtoupakovka-i-raspakovka-v-java>

### 55 Дан код:

```java
Integer a=3,b=7;
        Long c=a+b;
```

Перечислите все операции, где задействованы `autoboxing` и `unboxing`.  
**Ответ.**  
Autoboxing - `Integer a = 3, b = 7; Long c = a + b;`
Unboxing - `a + b;`

### 56 Дан корректный раннер-класс. Будет ли ошибка компиляции, если удалить модификатор `static` из сигнатуры метода `main()`? Обоснуйте ответ. Что произойдет, если отправить на выполнение измененный класс?

**Ответ.**  
Данный метод перестанет быть точкой входа в программу и станем просто нестатическим методом класса Runner с именем main.
Запустить Runner в таком случае мы не сможем.

### 57 Дан класс.

```java
class Runner {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

### Запрещается изменять синий код, т.е. метод `main()`. Добавить код в класс `Runner`, так чтобы в результате запуска этого класса из под `JVM` в консоли был следующий результат:

```
I am java.
Hello, world!
```

**Ответ.**

```java
class Runner {
    static {
        System.out.println("I am java.");
    }

    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

### 58 Бонусное задание 1 (необязательное) В задаче classes3 имеются два константных поля в классе покупки. Им сразу присваиваются значения по умолчанию. Например.

```java
public class Purchase {
    public final static String PRODUCT_NAME = "milk";
    public final static int PRICE = 120;
...
}
```

Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете,
что и класс покупки. Имя файла - константа в классе покупки. Если будет сбой с файлом или в нем будут недопустимые
значения, то присвойте константам `PRODUCT_NAME` и `PRICE` значения по умолчанию. Для этого же примера начало класса
должно быть таким:

```java
public class Purchase {
    private static final String PRODUCT_NAME;
    private static final int PRICE;
    public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
    private static final String DEFAULT_PRODUCT_NAME = "milk";
    private static final int DEFAULT_PRICE = 120;
```

**Ответ.**

```java
public class Purchase {
    public static final String PRODUCT_NAME;
    public static final int PRICE;
    private static
    final String FILE_NAME = "src/com/example/test02/in.txt";
    private static final String DEFAULT_PRODUCT_NAME = "milk";
    private static final int DEFAULT_PRICE = 120;

    static {
        String name = "";
        int price = 0;
        try (Scanner scanner = new Scanner(new FileReader(FILE_NAME))) {
            name = scanner.next();
            price = scanner.nextInt();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            name = DEFAULT_PRODUCT_NAME;
            price = DEFAULT_PRICE;
        } finally {
            PRODUCT_NAME = name;
            PRICE = price;
        }
    }
}
```
