Как по терминологии Java называются базовый класс и наследуемый класс?
Ответ.
Источник.

Какой класс является родительским для всех классов?

Какой класс является родительским для всех перечислений?

Какой интерфейс является родительским для всех интерфейсов?

Сформулируйте критерий отношения наследования между двумя сущности физического мира.
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?

Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник;
б) сосна и доска;
в) книга и страница?
Поясните ответ.

В чем смысл конструкции  super?
Перечислите случаи, когда используется конструкция  super.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?

Можно ли одновременно использовать this() и super() в конструкторе?
Поясните ответ.

Дан код.
class SomeClass() {
...
public SomeClass() {
doSmth();
}
protected void doSmth() {
...
}
}
Это потенциальный антипаттерн. Почему?

Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?


Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?

Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?

Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?

Можно ли переопределить статический метод? Поясните ответ.


Как запретить переопределение метода в подклассе? Назовите 2 способа.

С помощью какого механизма реализуется полиморфизм в Java?

Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?

SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните.
class EntityFactory {
public static Entity getEntity(int num) {
switch(num) {
case 2: return new Entity();
case 3: return new SmallEntity();
case 4: return new BigEntity();
default: throw new IllegalArgumentException();
}
}
}

Можно ли отрефакторить данный код? Если да, то выполните.
class Entity {
...
private String action;
public void doSmth() {
switch(action) {
case "sing-solo": singSolo(); break;
case "sing-duet": singDuet(); break;
case "dance": dance();
}
}
private void singSolo() {
...
}
private void singDuet() {
...
}
private void dance() {
...
}
}

Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
1. b = i; ?
2. i = b; ?

В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?

Можно ли создать:
1. ссылку на объект абстрактного класса?
2. объект абстрактного класса?
3. ссылку на интерфейс?
4. объект типа интерфейс?

Может ли класс:
1. реализовывать два интерфейса?
2. расширять два класса?
3. расширять два интерфейса?
4. расширять один класс и реализовывать один интерфейс?
5. расширять сам себя?

Для каких целей используется расширение интерфейса?

Могут ли в интерфейсе быть поля?

Можно ли в интерфейсе
1. объявить метод с пакетным уровнем доступа?
2. объявить конструктор?
3. определить конструктор?

Можно ли интерфейс объявить финальным? Поясните ответ.

Можно ли в интерфейсе объявить статический метод? Поясните ответ.


Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.

Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?

Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?

Что означает ключевое слово final в следующих конструкциях?
1.
public final class SomeClass() { }
2.
public class SomeClass() {
public final void doSmth();
}

Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.

К каким методам неприменимы принципы позднего связывания? Почему?

В чем заключается отличие между ранним и поздним связыванием?

Бонусное задание 1 (необязательное)
Добавить к задаче inheritance2 пункт:
8. Найти в отсортированном массиве ВСЕ покупки со стоимостью 5.00 BYN, для первоначального поиска использовав метод Arrays.binarySearch( ).
   Желательно найти такое решение, которое после поиска позволяет выполнить задачу за один цикл.
   Трюки типа Arrays.copyOfRange() не засчитываются, т.к. они реализованы через цикл.
   То есть если быть максимально точным, то должен быть один цикл, и вычислительная сложность алгоритма после вызова метода Arrays.binarySearch( ) должна быть равна O(n). 
