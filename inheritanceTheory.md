### 1. Как по терминологии Java называются базовый класс и наследуемый класс?

**Ответ.**  
Один класс может наследовать или расширять поля и методы другого класса с помощью ключевого слова extends. Класс,
который выступает базой для расширения, называют суперклассом, класс, который непосредственно проводит расширение - подклассом.  
**Источник.** <https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html>

### 2. Какой класс является родительским для всех классов?

**Ответ.**  
Класс `java.lang.Object` - родительский для всех классов.

### 3. Какой класс является родительским для всех перечислений?

**Ответ.**  
Класс `java.lang.Enum` - родительский для всех перечислений.

### 4. Какой интерфейс является родительским для всех интерфейсов?

**Ответ.**  
Хотя каждый класс является расширением класса Object, не существует единого интерфейса, расширениями которого были бы
все интерфейсы.
**Источник.**<https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html>

### 5. Сформулируйте критерий отношения наследования между двумя сущности физического мира.

### Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?
### Есть ли отношение наследования между сущностями:
### а) квадрат и прямоугольник;
### б) сосна и доска;
### в) книга и страница?
### Поясните ответ.

**Ответ.**  
Отношения наследования между двумя сущности физического мира: IS-A (есть, является).  
а) квадрат и является частным случаем прямоугольника, поэтому отношение наследования есть;  
б) не каждая сосна будет переработана в доску и не каждая доска сделана из сосны, отношения наследования нет;  
в) книга и страница - нет, применимо отношение HAS-A, что является композицией;

### 6. В чем смысл конструкции super?
### Перечислите случаи, когда используется конструкция super. В каких случаях можно обойтись без неё,т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

**Ответ.**
Если нужно получить доступ к версии переопределённого метода или конструктора, определённого в суперклассе, то используйте ключевое слово super. или super().

### 7. Можно ли одновременно использовать this() и super() в конструкторе? Поясните ответ.

**Ответ.**  
Нет нельзя. Так как вызов конструктора суперкласса должен быть первой строкой в конструкторе подкласса и вызов другого
конструктора этого же класса должен быть первой строкой в конструкторе. То использование this() и super() в одном и том
же конструкторе недопустимо.  
**Источник.**<https://docs.oracle.com/javase/tutorial/java/IandI/super.html>

### 8. Это потенциальный антипаттерн. Почему?

Дан код.

```java
class SomeClass() {
...

    public SomeClass() {
        doSmth();
    }

    protected void doSmth() {
...
    }
}
```

**Ответ.**  
Переопрделение методоа, который определен в конструкторе не является хорошей практикой. Такие действия приведут к 
некорректному создания объекта.

### 9. Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?

**Ответ.**  
Ранее до JDK 8 при реализации интерфейса мы должны были обязательно реализовать все его методы в классе. А сам интерфейс 
мог содержать только определения методов без конкретной реализации. В JDK 8 была добавлена такая функциональность как 
методы по умолчанию. И теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая 
используется, если класс, реализующий данный интерфейс, не реализует метод.  
**Источник.**<https://metanit.com/java/tutorial/3.7.php>

### 10. Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?

**Ответ.**  
Интерфейс без методов называется интерфейсом тегов. Есть две простые дизайнерские цели для интерфейсов тегов:  
* Создаёт общего родителя: вы можете использовать интерфейс тегов, чтобы создать общего родителя среди группы интерфейсов.  
* Добавляет тип данных в класс – эта ситуация является источником термина «тегирование». Класс, который реализует интерфейс тегов, 
не должен определять какие-либо методы (т.к. интерфейс не имеет таковых), но класс становится типом интерфейса через полиморфизм.  
**Источник.**<http://proglang.su/java/interfaces>

### 11. Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?

**Ответ.**  
Переопределить метод - реализовать новый метод, замещающий соответствующий метод из суперкласса.  
Перегрузка может ограничиваться одним классом. Методы с одинаковыми именами, но с различными списком параметров и
возвращаемыми значениями, могут находиться в разных классах одной цепочки наследования и также будут перегруженными.  
**Источник.** Источник. Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

### 12. Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?

**Ответ.**  
Если объявление метода подкласса полностью, включая параметры, совпадает с объявлением метода суперкласса (
порождающего класса), то метод подкласса переопределяет (overriding) метод суперкласса.
Методы с одинаковыми именами, но с различными списком параметров и возвращаемыми значениями, могут находиться в
разных классах одной цепочки наследования и будут перегруженными.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

### 13. Можно ли переопределить статический метод? Поясните ответ.

**Ответ.**  
Метод с ключевым словом static переопределить нельзя. Метод с модификатором static относится к классу, а не к его объектам. 
Для него работает статическое связывание, поэтому именно переопределение (override) в дочернем классе не работает.
Несмотря на это, в дочернем классе можно объявить static метод с такой же сигнатурой, как в родительском. В этом случае 
произойдет не перегрузка и не переопределение, а перекрытие (shadowing). К такому методу нельзя применить аннотацию 
@Override, в нём нельзя использовать ключевое слово super.  
**Источник.**<https://itsobes.ru/JavaSobes/mozhno-li-pereopredelit-staticheskii-metod/>

### 14. Как запретить переопределение метода в подклассе? Назовите 2 способа.

**Ответ.**  
* Методы, объявленные как final, нельзя замещать в подклассах.
* Метод с ключевым словом static переопределить нельзя.
* Модификатор доступа private сделает недоступным метод для подкласса и его нельзя будет переопределить.  
**Источник.**<https://www.geeksforgeeks.org/different-ways-to-prevent-method-overriding-in-java/#:~:text=The%20final%20way%20of%20preventing,class%20can%20override%20the%20behavior.>


### 15. С помощью какого механизма реализуется полиморфизм в Java?

**Ответ.**  
Переопределение методов является основой концепции динамического связывания, реализующей полиморфизм. Когда переопределенный 
метод вызывается через ссылку суперкласса, Java определяет, какую версию метода вызвать, основываясь на типе объекта, на 
который имеется ссылка. Таким образом, тип объекта определяет версию метода на этапе выполнения.  
**Источник.**<Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.>

### 16. Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?

**Ответ.**  
Cсылка базового класса может ссылаться на объекты своих производных типов и объект производного класса может быть использован 
везде, где ожидается объект его базового типа.
```java
class A{}
class B extends A{}
B b = new B();
A a = b;
```

### 17. Можно ли отрефакторить данный код? Если да, то выполните.

SmallEntity и BigEntity - это подклассы Entity.
```java
class EntityFactory {
    public static Entity getEntity(int num) {
        switch (num) {
            case 2:
                return new Entity();
            case 3:
                return new SmallEntity();
            case 4:
                return new BigEntity();
            default:
                throw new IllegalArgumentException();
        }
    }
}
```
**Ответ.**  
```java
public class EntityFactory {
    public enum EntityType {
        ENTITY {
            @Override
            Entity getEntity() {
                return new Entity();
            }
        },
        SMALL_ENTITY {
            @Override
            Entity getEntity() {
                return new SmallEntity();
            }
        },
        BIG_ENTITY {
            @Override
            Entity getEntity() {
                return new BigEntity();
            }
        };
        abstract Entity getEntity();
    }
    private EntityFactory() {
    }
    public static Entity getEntity(EntityType type) {
        return type.getEntity();
    }
}
```

### 18. Можно ли отрефакторить данный код? Если да, то выполните.
```java
class Entity {
...
    private String action;
    public void doSmth() {
        switch (action) {
            case "sing-solo":
                singSolo();
                break;
            case "sing-duet":
                singDuet();
                break;
            case "dance":
                dance();
        }
    }
    private void singSolo() {
...
    }
    private void singDuet() {
...
    }
    private void dance() {
...
    }
}
```

**Ответ.**  
```java
public class Entity {
    public enum Action {
        SING_SOLO {
            @Override
            void doAction() {
            }
        },
        SING_DUET {
            @Override
            void doAction() {
            }
        },
        DANCE {
            @Override
            void doAction() {
            }
        };

        abstract void doAction();
    }

    private Action action;

    public Action getAction() {
        return action;
    }

    public void setAction(Action action) {
        this.action = action;
    }

    public void doSmth() {
        action.doAction();
    }

} 
```

### 19. Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
### Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
### 1. b = i; ?
### 2. i = b; ?

**Ответ.**  
Если вы объявляете класс, производный от абстрактного класса, но хотите иметь возможность создания объектов нового типа, 
вам придётся предоставить определения для всех абстрактных методов базового класса. Если этого не сделать, производный класс 
тоже останется абстрактным, и компилятор заставит пометить новый класс ключевым словом abstract.
Создание возможно. Интерфейсы не имеют конструкторов, поэтому мы не можем использовать "условный" конструктор интерфейса. Но мы можем использовать 
конструктор класса, который реализует интерфейс, для создания объекта интерфейса.
* b = i; - возможно через явное приведение:b = (B) i;
* i = b; - операция возможна.  
**Источник.**<http://developer.alexanderklimov.ru/android/java/abstract.php>

### 20. В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?

**Ответ.**  
getClass() возвращает true, если объект является экземпляром класса в отличие от instanceof, который вернет значение true,
если объект принадлежит производному классу исходного суперкласса.  
**Источник.**<https://stackoverflow.com/questions/4989818/instanceof-vs-getclass>

### 21. Можно ли создать:
### 1. ссылку на объект абстрактного класса?
### 2. объект абстрактного класса?
### 3. ссылку на интерфейс?
### 4. объект типа интерфейс?

**Ответ.**  


### 22. Может ли класс:
### 1. реализовывать два интерфейса?
### 2. расширять два класса?
### 3. расширять два интерфейса?
### 4. расширять один класс и реализовывать один интерфейс?
### 5. расширять сам себя?

**Ответ.**

**Источник.**<>

### 23. Для каких целей используется расширение интерфейса?

**Ответ.**

**Источник.**<>

### 24. Могут ли в интерфейсе быть поля?

**Ответ.**

**Источник.**<>

### 25. Можно ли в интерфейсе:
### 1. объявить метод с пакетным уровнем доступа?
### 2. объявить конструктор?
### 3. определить конструктор?

**Ответ.**  

**Источник.**<>

### 26. Можно ли интерфейс объявить финальным? Поясните ответ.

**Ответ.**  

**Источник.**<>

### 27. Можно ли в интерфейсе объявить статический метод? Поясните ответ.

**Ответ.**

**Источник.**<>

### 28. Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.

**Ответ.**

**Источник.**<>

### 29. Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?

**Ответ.**

**Источник.**<>

### 30. Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?

**Ответ.**

**Источник.**<>

### 31. Что означает ключевое слово final в следующих конструкциях?

1. `public final class SomeClass() { }`

2.
```java
public class SomeClass() {
    public final void doSmth();
}
```

**Ответ.**

**Источник.**<>

### 32. Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.

**Ответ.**

**Источник.**<>

### 33. К каким методам неприменимы принципы позднего связывания? Почему?

**Ответ.**

**Источник.**<>

### 34. В чем заключается отличие между ранним и поздним связыванием?

**Ответ.**

**Источник.**<>

### 35. Бонусное задание 1 (необязательное)

### Добавить к задаче inheritance2 пункт:

### 8. Найти в отсортированном массиве ВСЕ покупки со стоимостью 5.00 BYN, для первоначального поиска использовав метод Arrays.binarySearch( ).
### Желательно найти такое решение, которое после поиска позволяет выполнить задачу за один цикл.
### Трюки типа Arrays.copyOfRange() не засчитываются, т.к. они реализованы через цикл.
### То есть если быть максимально точным, то должен быть один цикл, и вычислительная сложность алгоритма после вызова метода
### Arrays.binarySearch( ) должна быть равна O(n).

**Ответ.**  

