### 1. Как по терминологии Java называются базовый класс и наследуемый класс?

**Ответ.**  
Один класс может наследовать или расширять поля и методы другого класса с помощью ключевого слова extends. Класс,
который выступает базой для расширения, называют суперклассом, класс, который непосредственно проводит расширение - подклассом.  
**Источник.** <https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html>

### 2. Какой класс является родительским для всех классов?

**Ответ.**  
Класс `java.lang.Object` - родительский для всех классов.

### 3. Какой класс является родительским для всех перечислений?

**Ответ.**  
Класс `java.lang.Enum` - родительский для всех перечислений.

### 4. Какой интерфейс является родительским для всех интерфейсов?

**Ответ.**  
Хотя каждый класс является расширением класса Object, не существует единого интерфейса, расширениями которого были бы
все интерфейсы.  
**Источник.**<https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html>

### 5. Сформулируйте критерий отношения наследования между двумя сущности физического мира.
### Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?
### Есть ли отношение наследования между сущностями:
### а) квадрат и прямоугольник;
### б) сосна и доска;
### в) книга и страница?
### Поясните ответ.

**Ответ.**  
Отношения наследования между двумя сущности физического мира: IS-A (есть, является).  
а) квадрат и является частным случаем прямоугольника, поэтому отношение наследования есть;  
б) не каждая сосна будет переработана в доску и не каждая доска сделана из сосны, отношения наследования нет;  
в) книга и страница - нет, применимо отношение HAS-A, что является композицией;

### 6. В чем смысл конструкции super?
### Перечислите случаи, когда используется конструкция super. В каких случаях можно обойтись без неё,т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

**Ответ.**
Если нужно получить доступ к версии переопределённого метода или конструктора, определённого в суперклассе, то используйте ключевое слово super. или super().

### 7. Можно ли одновременно использовать this() и super() в конструкторе? Поясните ответ.

**Ответ.**  
Нет нельзя. Так как вызов конструктора суперкласса должен быть первой строкой в конструкторе подкласса и вызов другого
конструктора этого же класса должен быть первой строкой в конструкторе. То использование this() и super() в одном и том
же конструкторе недопустимо.  
**Источник.**<https://docs.oracle.com/javase/tutorial/java/IandI/super.html>

### 8. Это потенциальный антипаттерн. Почему?
Дан код.
```java
class SomeClass() {
...

    public SomeClass() {
        doSmth();
    }

    protected void doSmth() {
...
    }
}
```
**Ответ.**  
Переопрделение методоа, который определен в конструкторе не является хорошей практикой. Такие действия приведут к 
некорректному создания объекта.

### 9. Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?

**Ответ.**  
Ранее до JDK 8 при реализации интерфейса мы должны были обязательно реализовать все его методы в классе. А сам интерфейс 
мог содержать только определения методов без конкретной реализации. В JDK 8 была добавлена такая функциональность как 
методы по умолчанию. И теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая 
используется, если класс, реализующий данный интерфейс, не реализует метод.  
**Источник.**<https://metanit.com/java/tutorial/3.7.php>

### 10. Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?

**Ответ.**  
Интерфейс без методов называется интерфейсом тегов. Есть две простые дизайнерские цели для интерфейсов тегов:  
* Создаёт общего родителя: вы можете использовать интерфейс тегов, чтобы создать общего родителя среди группы интерфейсов.  
* Добавляет тип данных в класс – эта ситуация является источником термина «тегирование». Класс, который реализует интерфейс тегов, 
не должен определять какие-либо методы (т.к. интерфейс не имеет таковых), но класс становится типом интерфейса через полиморфизм.  
**Источник.**<http://proglang.su/java/interfaces>

### 11. Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?

**Ответ.**  
Методы класса можно переопределять — сделать override. Или перегрузить — сделать overload. 
Переопределение метода - создание нового метода с той же сигнатурой, который замещает этот же метод из суперкласса. Переопределяемые 
методы лучше предварять аннотацией @Override. В этом случае компилятор получает возможность проверить, что вы переопределили метод, 
а не написали новый. Таким образом можно избежать некоторых ошибок из-за невнимательности.
Перегрузка - создание метода с тем же именем, но с другими аргументами(количеством либо их отсутствием) и возвращаемым значением.
Перегрузку можно реализовать в одном классе, либо в разных классах одной иерархии наследования.  
**Источник.** <https://java-course.ru/begin/override-overload/>

### 12. Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?

**Ответ.**  
Если объявление метода подкласса полностью, включая параметры, совпадает с объявлением метода суперкласса (
порождающего класса), то метод подкласса переопределяет (overriding) метод суперкласса.
Методы с одинаковыми именами, но с различными списком параметров и возвращаемыми значениями, могут находиться в
разных классах одной цепочки наследования и будут перегруженными.  
**Источник.** <https://habr.com/ru/company/otus/blog/347900/>

### 13. Можно ли переопределить статический метод? Поясните ответ.

**Ответ.**  
Метод с ключевым словом static переопределить нельзя. Метод с модификатором static относится к классу, а не к его объектам. 
Для него работает статическое связывание, поэтому именно переопределение (override) в дочернем классе не работает.
Несмотря на это, в дочернем классе можно объявить static метод с такой же сигнатурой, как в родительском. В этом случае 
произойдет не перегрузка и не переопределение, а перекрытие (shadowing). К такому методу нельзя применить аннотацию 
@Override, в нём нельзя использовать ключевое слово super.  
**Источник.**<https://itsobes.ru/JavaSobes/mozhno-li-pereopredelit-staticheskii-metod/>

### 14. Как запретить переопределение метода в подклассе? Назовите 2 способа.

**Ответ.**  
* Методы, объявленные как final, нельзя замещать в подклассах.  
* Модификатор доступа private сделает недоступным метод для подкласса и его нельзя будет переопределить.  
**Источник.**<https://www.geeksforgeeks.org/different-ways-to-prevent-method-overriding-in-java/#:~:text=The%20final%20way%20of%20preventing,class%20can%20override%20the%20behavior.>

### 15. С помощью какого механизма реализуется полиморфизм в Java?

**Ответ.**  
В Java есть два типа полиморфизма: полиморфизм времени компиляции и полиморфизм времени выполнения. Мы можем реализовать
полиморфизм в java путем перегрузки и переопределения методов.
Полиморфизм времени компиляции (статическое связывание) и полиморфизм времени выполнения (динамическое связывание). Перегрузка 
метода — пример статического полиморфизма, а переопределение метода — пример динамического полиморфизма.  
**Источник.** <https://www.javatpoint.com/runtime-polymorphism-in-java#:~:text=There%20are%20two%20types%20of,example%20of%20compile%20time%20polymorphism.>

### 16. Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?

**Ответ.**  
Cсылка базового класса может ссылаться на объекты своих производных типов и объект производного класса может быть использован 
везде, где ожидается объект его базового типа.
```java
class A{}
class B extends A{}
B b = new B();
A a = b;
```

### 17. Можно ли отрефакторить данный код? Если да, то выполните.
SmallEntity и BigEntity - это подклассы Entity.
```java
class EntityFactory {
    public static Entity getEntity(int num) {
        switch (num) {
            case 2:
                return new Entity();
            case 3:
                return new SmallEntity();
            case 4:
                return new BigEntity();
            default:
                throw new IllegalArgumentException();
        }
    }
}
```
**Ответ.**  
```java
public class EntityFactory {
    public enum EntityType {
        ENTITY {
            @Override
            Entity getEntity() {
                return new Entity();
            }
        },
        SMALL_ENTITY {
            @Override
            Entity getEntity() {
                return new SmallEntity();
            }
        },
        BIG_ENTITY {
            @Override
            Entity getEntity() {
                return new BigEntity();
            }
        };
        abstract Entity getEntity();
    }
    private EntityFactory() {
    }
    public static Entity getEntity(EntityType type) {
        return type.getEntity();
    }
}
```

### 18. Можно ли отрефакторить данный код? Если да, то выполните.
```java
class Entity {
...
    private String action;
    public void doSmth() {
        switch (action) {
            case "sing-solo":
                singSolo();
                break;
            case "sing-duet":
                singDuet();
                break;
            case "dance":
                dance();
        }
    }
    private void singSolo() {
...
    }
    private void singDuet() {
...
    }
    private void dance() {
...
    }
}
```
**Ответ.**  
```java
public class Entity {
    public enum Action {
        SING_SOLO {
            @Override
            void doAction() {
            }
        },
        SING_DUET {
            @Override
            void doAction() {
            }
        },
        DANCE {
            @Override
            void doAction() {
            }
        };

        abstract void doAction();
    }

    private Action action;

    public Action getAction() {
        return action;
    }

    public void setAction(Action action) {
        this.action = action;
    }

    public void doSmth() {
        action.doAction();
    }

} 
```

### 19. Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
### Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
### 1. b = i; ?
### 2. i = b; ?

**Ответ.**  
Если вы объявляете класс, производный от абстрактного класса, но хотите иметь возможность создания объектов нового типа, 
вам придётся предоставить определения для всех абстрактных методов базового класса. Если этого не сделать, производный класс 
тоже останется абстрактным, и компилятор заставит пометить новый класс ключевым словом abstract.
Создание возможно. Интерфейсы не имеют конструкторов, поэтому мы не можем использовать "условный" конструктор интерфейса. Но мы можем использовать 
конструктор класса, который реализует интерфейс, для создания объекта интерфейса.
* b = i; - возможно через явное приведение:b = (B) i;
* i = b; - операция возможна.  
**Источник.**<http://developer.alexanderklimov.ru/android/java/abstract.php>

### 20. В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?

**Ответ.**  
getClass() возвращает true, если объект является экземпляром класса в отличие от instanceof, который вернет значение true,
если объект принадлежит и суперклассу, и производному классу этого же суперкласса.  
**Источник.**<https://stackoverflow.com/questions/4989818/instanceof-vs-getclass>

### 21. Можно ли создать:
### 1. ссылку на объект абстрактного класса?
### 2. объект абстрактного класса?
### 3. ссылку на интерфейс?
### 4. объект типа интерфейс?

**Ответ.**  
1. Можно, но для этого необходимо создать производный класс и определить все методы абстрактного суперкласса (необходимо
для того, чтобы производный не стал в свою очередь абстрактным, компилятор выдаст ошибку), далее можно получить ссылку на 
объект абстрактного суперкласса через объект производного от него.
2. В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса. 
Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал.
3. Если класс реализует данный интерфейс, то допускается ссылка на интерфейс, которая указывает на экземпляр класса.
4. Интерфейсы говорят о том, что класс может делать, но не говорят, как он должен это делать. Интерфейс только гарантирует (определяет контракт).
Поэтому в интерфейсе нельзя создавать объекты типа интерфейс.  

### 22. Может ли класс:
### 1. реализовывать два интерфейса?
### 2. расширять два класса?
### 3. расширять два интерфейса?
### 4. расширять один класс и реализовывать один интерфейс?
### 5. расширять сам себя?

**Ответ.**  
1. Реализация интерфейса происходит в классе с помощью ключевого слова implements. Если реализуемых интерфейсов несколько, то они перечисляются через запятую.
2. Класс не может расширять несколько классов, для этого существует реализация нескольких интерфейсов в одном классе.
3. Если интерфейс призван расширять функционал класса, то класс их реализовывает, но не наследует.
4. Класс может расширять другой класс при помощи ключевого слова extends, а также реализовывать один или несколько интерфейсов при помощи ключевого слова implements.
5. Такое невозможно, так как существует понятие наследование класса (IS - A).  

### 23. Для каких целей используется расширение интерфейса?

**Ответ.**  
Основной целью расширение интерфейсов является создание более спцифичного функционала. Происходит также как расширение классов
при помощи ключевого слова extends.  
**Источник.**<https://hr-vector.com/java/kak-rasshirit-interfejsy>

### 24. Могут ли в интерфейсе быть поля?

**Ответ.**  
Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). 
Все методы и переменные неявно объявляются как public.  
**Источник.**<http://developer.alexanderklimov.ru/android/java/interface.php>

### 25. Можно ли в интерфейсе:
### 1. объявить метод с пакетным уровнем доступа?
### 2. объявить конструктор?
### 3. определить конструктор?

**Ответ.**  
1. Все методы интерфейса не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - 
определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.
2. В интерфейсе нельзя объявить конструктор, т.к. назначение интерфейса - это что класс может делать, но не говорит, как он должен это делать.
Интерфейс только гарантирует (определяет контракт).  
**Источник.**<https://metanit.com/java/tutorial/3.7.php>

### 26. Можно ли интерфейс объявить финальным? Поясните ответ.

**Ответ.**  
Если интерфейс был объявлен final - это означает, что никакой другой интерфейс не может его расширить, ни один класс не 
может реализовать интерфейс.

### 27. Можно ли в интерфейсе объявить статический метод? Поясните ответ.

**Ответ.**  
В отличие от других методов интерфейса, статические методы содержат полное определение функции, и, поскольку определение 
завершено, а метод является статическим, эти методы нельзя переопределить или изменить в классе реализации.  
**Источник.**<https://www.geeksforgeeks.org/static-method-in-interface-in-java/>  

### 28. Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.

**Ответ.**  
Т.к. статические поля и методы принадлежат классу, то и вызов статического метода можно делать только через 
Имя_класса.имя_метода(параметоры), но никак не через объектную ссылку.  
**Источник.**<https://javarush.ru/quests/lectures/questsyntaxpro.level11.lecture02>

### 29. Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?

**Ответ.**  
Если класс имеет абстрактным метод, то и сам класс является абстрактным. В абстрактном можно определить поля и 
методы, но в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять 
базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал.  
**Источник.**<https://metanit.com/java/tutorial/3.6.php>

### 30. Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?

**Ответ.**  
В абстрактном классе может не быть ни одного абстрактного метода, такой класс необходим для расширения функционала производных классов, где
можно реализовать необходимые методы.  
**Источник.**<https://javarush.ru/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java>

### 31. Что означает ключевое слово final в следующих конструкциях?
1. `public final class SomeClass() { }`  
2.
```java
public class SomeClass() {
    public final void doSmth();
}
```
**Ответ.**  
1. final-класс, запрещает наследование и создание подклассов от него.
2. final-метод - финальная версия метода, ни один производный класс не в состоянии переопределить данный метод.

### 32. Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.

**Ответ.**  
Нет, в Java нельзя сделать абстрактный класс или метод окончательным, потому что abstract и final являются
взаимоисключающими понятиями. Абстрактный класс является неполным и может быть создан только путем расширения конкретного
класса и реализации всех абстрактных методов, в то время как окончательный класс считается полным и не может быть расширен дальше.
Это означает, что когда вы делаете абстрактный класс или метод окончательным, его нельзя расширить, следовательно, его нельзя использовать, 
и поэтому компилятор Java выдает ошибку "illegal combination of modifiers: abstract and final" error.  
**Источник.**<https://stackoverflow.com/questions/1299398/can-an-abstract-class-have-a-final-method>

### 33. К каким методам неприменимы принципы позднего связывания? Почему?

**Ответ.**  
Для методов с уровнем доступа private и final-методам неприменим принцип позднего связывания. Переопределение - это механизм
позднего связывания. Соответственно private и final методы невозможно переопределить.  
**Источник.**<http://pr0java.blogspot.com/2015/07/blog-post_66.html>

### 34. В чем заключается отличие между ранним и поздним связыванием?

**Ответ.**  
Раннее связывание - это когда метод, который будет вызван, известен во время компиляции.
Позднее связывание - это когда метод, который будет вызван, определяется во время компиляции.
Перегрузка - это раннее связывание, а переопределение - позднее связывание.  
