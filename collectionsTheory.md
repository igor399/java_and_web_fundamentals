### 1. Дайте неформальное определение контейнера.  
**Ответ.**  
Коллекции — это хранилища или контейнеры, поддерживающие различные
способы накопления и упорядочения объектов с целью обеспечения возможностей 
эффективного доступа к ним. Они представляют собой реализацию абстрактных 
структур данных, поддерживающих три основные операции:  
* добавление нового элемента в коллекцию;  
* удаление элемента из коллекции;  
* изменение элемента в коллекции.  
В качестве других операций могут быть реализованы следующие: заменить,
просмотреть элементы, подсчитать их количество и др.  
**Источник.**Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.  


### 2. Дайте определение коллекции в java.  
**Ответ.**  
Коллекция, иногда называемая контейнером, — это просто объект, объединяющий 
несколько элементов в единое целое. Коллекции используются для хранения, 
извлечения, обработки и передачи агрегированных данных. Как правило, они 
представляют собой элементы данных, образующие естественную группу, например 
покерную комбинацию (набор карт), почтовую папку (набор писем) или телефонный 
справочник (сопоставление имен с номерами телефонов). Если вы использовали язык 
программирования Java или любой другой язык программирования, вы уже знакомы с 
коллекциями.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 3. Какой имеется в java контейнер, отличный от коллекций?  Дайте ему определение.
**Ответ.**  
Массив — это объект-контейнер, который содержит фиксированное количество значений 
одного типа. Длина массива устанавливается при создании массива. После создания 
его длина фиксируется.  
**Источник.**<https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html>


### 4. Дайте определение Collections framework?  
**Ответ.**  
Collections framework - это унифицированная архитектура для представления и
манипулирования коллекциями.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 5. Какие разделы содержит Collections framework?  Определите их, и для чего они предназначены?  
**Ответ.**  
* Interfaces: это абстрактные типы данных, представляющие коллекции. Интерфейсы 
позволяют управлять коллекциями независимо от деталей их представления. В 
объектно-ориентированных языках интерфейсы обычно образуют иерархию.  
* Реализации (Implementations): это конкретные реализации интерфейсов коллекций. 
  По сути, это повторно используемые структуры данных.  
* Алгоритмы : Это методы, которые выполняют полезные вычисления, такие как поиск 
  и сортировка, над объектами, которые реализуют интерфейсы коллекций. Алгоритмы
  называются полиморфными: то есть один и тот же метод может использоваться во 
  многих различных реализациях соответствующего интерфейса коллекции. По сути, 
  алгоритмы — это повторно используемые функции.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 6. В чем преимущества использования Collections Framework
**Ответ.**  
* Сокращает усилия по программированию: Предоставляя полезные структуры данных и 
алгоритмы, Collections Framework позволяет вам сконцентрироваться на важных частях 
вашей программы, а не на низкоуровневой «сантехнике», необходимой для ее работы. 
Упрощая взаимодействие между несвязанными API, Java Collections Framework освобождает 
вас от написания объектов адаптера или кода преобразования для подключения API. 
  
* Увеличивает скорость и качество программы: эта структура коллекций обеспечивает 
высокопроизводительные и высококачественные реализации полезных структур данных 
и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому 
программы можно легко настраивать, переключая реализации коллекций. Поскольку 
вы освобождаетесь от рутинной работы по написанию собственных структур данных, 
у вас появляется больше времени для улучшения качества и производительности программ. 
  
* Обеспечивает взаимодействие между несвязанными API: интерфейсы коллекций — 
это язык, с помощью которого API передают коллекции туда и обратно. Если мой 
API-интерфейс сетевого администрирования предоставляет набор имен узлов, а ваш 
инструментарий GUI ожидает набор заголовков столбцов, наши API-интерфейсы будут 
беспрепятственно взаимодействовать, даже если они были написаны независимо друг 
от друга.  
  
* Сокращает усилия по изучению и использованию новых API: многие API естественным 
образом принимают коллекции на входе и предоставляют их на выходе. Раньше у 
каждого такого API был небольшой суб-API, предназначенный для управления его 
коллекциями. Между этими специальными API-интерфейсами коллекций было мало 
согласованности, поэтому вам приходилось изучать каждый из них с нуля, и при 
их использовании было легко сделать ошибки. С появлением стандартных интерфейсов 
коллекций проблема ушла.  
  
* Сокращает усилия по разработке новых API: это обратная сторона предыдущего 
преимущества. Дизайнерам и разработчикам не нужно изобретать велосипед каждый 
раз, когда они создают API, основанный на коллекциях; вместо этого они могут 
использовать стандартные интерфейсы коллекций.  

* Способствует повторному использованию программного обеспечения: новые структуры 
данных, соответствующие стандартным интерфейсам коллекций, по своей природе допускают 
повторное использование. То же самое касается новых алгоритмов, работающих с 
объектами, реализующими эти интерфейсы.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 7. Является ли антипаттерном следующее объявление ссылки на коллекцию?  Если да, то как называется антипаттерн и исправьте объявление ссылки.
```java
Collection collection;
```
**Ответ.**  
Является грубым антипаттерном. Ссылка на коллекцию объявлена без параметризации, те
как raw-type или сырой тип. Нарушается типобезопасность.
```java
// Параметризованный тип коллекции - безопасно
private final Collection<Stamp> stamps = ... ;
```
**Источник.** Джошуа Блох, Java. Эффективное программирование. Третье издание.


### 8. К каким негативным последствиям может привести использование `raw types`?   Приведите пример.
**Ответ.**  
Мы получаем предгенерированное поведение с необработанными типами. Таким образом, 
необработанный тип Список принимает Объект и может содержать элемент любого типа 
данных . Это может привести к проблемам безопасности типов, когда мы смешиваем 
параметризованные и необработанные типы.  
Посмотрим на это, создав некоторый код, который создает экземпляр List перед 
передачей его методу, который принимает необработанный тип List и добавляет к 
нему целое число:  
```java
public void methodA() {
    List parameterizedList = new ArrayList<>();
    parameterizedList.add("Hello Folks");
    methodB(parameterizedList);
}

public void methodB(List rawList) { // raw type!
    rawList.add(1);
}
```  
Код компилируется (с предупреждением), и Integer добавляется в необработанный 
тип List при выполнении. List, который был передан в качестве аргумента, 
теперь содержит Строку и Целое число.  
Отсутствие безопасности типов в необработанном типе имеет причинно-следственные 
последствия, которые могут привести к исключениям во время выполнения.  
Изменим предыдущий пример так, чтобы method получал элемент в позиции индекса 1
нашего List:  
```java
public void methodA() {
        List parameterizedList = new ArrayList<>();
        parameterizedList.add("Hello Folks");
        methodB(parameterizedList);
        String s = parameterizedList.get(1);
        }

public void methodB(List rawList) {
        rawList.add(1);
        }
```  
Код компилируется (с тем же предупреждением) и при выполнении выдает ClassCastException. 
Это происходит, когда метод get(int index) возвращает Целое число, которое не может 
быть присвоено переменной типа String.  
**Источник.** <https://javascopes.com/raw-types-java-d9ab869d/>


### 9. Почему допускаются raw types с коллекциями?  
**Ответ.**  
Есть всего три случая, когда использовать обобщенный тип без параметра правильно:
• Целевая версия Java < 5.0 (2002 год и ранее – вряд ли это ваш случай);
• В литерале класса. List<String>.class не сработает, нужно писать List.class;
• В операторе instanceof. Вместо instanceof Set<Integer> должно быть instanceof Set.  
**Источник.**<https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/>


### 10. Какое главное назначение раздела Интерфейсы?   Другими словами, если известен интерфейс коллекции, то что это дает программисту?    
**Ответ.**  
Основные интерфейсы коллекций инкапсулируют различные типы коллекций. 
Эти интерфейсы позволяют управлять коллекциями независимо от деталей их 
представления. Основные интерфейсы коллекций являются основой Java Collections 
Framework.  
Интерфейсы позволяют манипулировать коллекциями независимо от деталей
конкретной реализации, реализуя тем самым принцип полиморфизма.
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 11. Какое главное назначение раздела Имплементации?  Другими словами, если известна имплементация, то что это дает программисту?  
**Ответ.**  
Реализации (Implementations) — это объекты данных, используемые для хранения коллекций, которые 
реализуют интерфейсы.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 12. Приведите иерархию интерфейсов коллекций.
**Ответ.**  
* interface Collection extends Iterable;  
* interface List, Queue, Set extends Collection;
* interface Deque extends Queue;
* interface SortedSet extends Set;
* interface NavigableSet extends SortedSet;
  
* interface SortedMap extends Map;
* interface NavigableMap extends SortedMap;
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html>


### 13. Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?  
### Какой способ является более подходящим для прохода по коллекции до версии java 8?
### Приведите идиомы для следующей коллекции:
```java
Collection<Entity> entities = …;
```
**Ответ.**  
Существует два способа обхода коллекций: (1) с конструкцией for-each и (2) с 
использованием итераторов.  
Цикл по коллекции (for-each, официально известный как "расширенный
цикл for") решает все указанные проблемы. Он избавляет программистов от
путаницы и возможностей для внесения ошибок, полностью скрывая итератор
или индексную переменную.  

for-each Construct:  
```java
// Предпочтительная идиома обхода элементов коллекции или массива
for (Entity entity : entities) {
    System.out.println(entity);
}
```
Iterators:  
```java
// Идиома обхода в случае необходимости доступа к итератору
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); ){
    System.out.println(it.next());
}
```
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>

### 14. Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?  
### Какой метод этого интерфейса обеспечивает данную возможность?  
**Ответ.**  
```java
interface Iterable<T>{
 Iterator<T> iterator(); // возвращает итератор по множеству элементов T
}
```   
Интерфейс Iterator<E> используется для доступа к элементам коллекции.  
Iterator<E> iterator() – возвращает итератор.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 15. Что такое итератор?  
**Ответ.**  
Итератор – это объект, который позволяет осуществлять обход коллекции и при
желании удалять избранные элементы.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 16. Дана коллекция из n элементов. Сколько в ней существует возможных позиций курсора итератора?  
**Ответ.**  
Итератор для списков, который позволяет программисту перемещаться по списку в 
любом направлении, изменять список во время итерации и получать текущую позицию 
итератора в списке. A ListIterator не имеет текущего элемента; его позиция курсора 
всегда находится между элементом, который будет возвращен вызовом, previous()и 
элементом, который будет возвращен вызовом next(). Итератор для списка длины 
nимеет n+1возможные позиции курсора.  
**Источник.**<https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ListIterator.html>


### 17. Какие методы объявлены в интерфейсе Iterator<E>?   Охарактеризуйте их.
**Ответ.**  
* boolean hasNext(): возвращает true при наличии следующего элемента, а в
случае его отсутствия возвращает false. Итератор при этом остается
неизменным;  
* Object next(): возвращает объект, на который указывает итератор, и
передвигает текущий указатель на следующий итератор, предоставляя доступ
к следующему элементу. Если следующий элемент коллекции отсутствует, то
метод next() генерирует исключение;  
* void remove(): удаляет объект, возвращенный последним вызовом метода
next();  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 18. В каких случаях следует явно использовать итератор вместо for-each?  
**Ответ.**  
Используйте Iterator вместо for-each если вам необходимо удалить текущий
элемент.
* Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove;  
* Также конструкция for-each не применима для фильтрации.
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 19. Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity.
### Приведите идиому удаления элементов этой коллекции.
**Ответ.**  
```java
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); ){
    if (it.next().isRemoved()){ 
        it.remove();
    }
}
```


### 20. Какие группы методов (или операций) объявлены в интерфейсе Collection (до java 8)?   Какие методы входят в каждую группу?  
**Ответ.**  
* boolean equals(Object o);  
* int size(): возвращает количество элементов в коллекции;  
* boolean isEmpty(): возвращает true, если коллекция пуста;  
* boolean contains(Object element): возвращает true, если коллекция
содержит элемент element;  
* boolean add(E element): добавляет element к вызывающей коллекции и
возвращает true, если объект добавлен, и false, если element уже
элемент коллекции;  
* boolean remove(Object element): удаляет element из коллекции;
* Iterator<E> iterator(): возвращает итератор  
* boolean containsAll(Collection<?> c): возвращает true, если коллекция
содержит все элементы из c;  
* boolean addAll(Collection<? extends E> c): добавляет все элементы
коллекции к вызывающей коллекции;  
boolean removeAll(Collection<?> c): удаление всех элементов данной
коллекции, которые содержаться в c;  
* boolean retainAll(Collection<?> c): удаление элементов данной
коллекции, которые не содержаться в коллекции c;  
* void clear(): удаление всех элементов;  
* Object[] toArray(): копирует элементы коллекции в массив объектов;  
* <T> T[] toArray(T[] a): возвращает массив, содержащий все элементы коллекции;  
* Iterator<T> iterator(): возвращает итератор по множеству элементов T.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.
  

### 21. В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?  
**Ответ.**  
* Object[] toArray(): копирует элементы коллекции в массив объектов;  
* <T> T[] toArray(T[] a): возвращает массив, содержащий все элементы коллекции;  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 22. В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”. Как это понимать?
**Ответ.**  
Некоторые методы интерфейса Collection могут быть не реализованы в
подклассах (нет необходимости их реализовывать). В этом случае метод генерирует
java.lang.UnsupportedOperationException (подкласс RuntimeException).  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 23. Какую математическую сущность моделирует интерфейс Set?  
**Ответ.**  
Множество ─ коллекция без повторяющихся элементов. Моделирует математическую 
абстракцию множества.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 24. Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?  
**Ответ.**  
Интерфейс Set<E> содержит методы, унаследованные Collection<E> и добавляет запрет 
на дублирующиеся элементы. Set также добавляет соглашение на поведение методов 
equals и hashCode, позволяющих сравнивать множества даже если их реализации 
различны. Два множества считаются равными, если они содержат одинаковые элементы.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 25. Может ли множество содержать null элемент?  
**Ответ.**  
HashSet можно вставить лишь одно значение null (уникальность элементов), 
TreeSet — только для первого элемента.  
**Источник.**<https://savepearlharbor.com/?p=164027>


### 26. Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?   Если нет, то есть ли у множества итератор?  
**Ответ.**  
Set — это неупорядоченное множество и не поддерживает порядок элементов.  
Интерфейс NavigableSet добавляет возможность перемещения, "навигации" по
отсортированному множеству.   
Возвращают итераторы коллекции в порядке возрастания и убывания элементов
соответственно:  
* Iterator<E> iterator();
* Iterator<E> descendingIterator();
* NavigableSet<E> descendingSet();
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 27. Как получить элемент множества по индексу?  
**Ответ.**  
Мы можем получить элементы по индексу в HashSet тремя различными способами:  
1. Использование массива;  
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Converting HashSet to Array
        String[] Geeks = GFG.toArray(new String[GFG.size()]);
  
        // Accessing elements by index
        System.out.println("Element at index 3 is: "
                           + Geeks[3]);
    }
}
```
2. Использование цикла for;  
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Iterator declaration
        int currentIndex = 0;
  
        // Desired Index
        int desiredIndex = 3;
        
        for (String element :GFG) { 
          // Implementing for loop
  
            if (currentIndex == desiredIndex)
            {
                System.out.println("Element at index 3 is: "+ element);
                break;
            }
            currentIndex++;
        }
    }
}
```

3. Использование списка массивов;  
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Converting HashSet to ArrayList
        List<String> list = new ArrayList<String>(GFG);
  
        System.out.println("Element at index 3 is: "
                           + list.get(3));
    }
}
```  
**Источник.**<https://www.geeksforgeeks.org/how-to-get-elements-by-index-from-hashset-in-java/>


### 28. Как реализован метод add() во множестве?  
**Ответ.**  
boolean add(E element); //добавляет element к вызывающему множеству и
возвращает true, если объект добавлен, и false, если element уже элемент
множества.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 29. Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?   Какие методы добавились?  
**Ответ.**  
Bulk group:  
s1.containsAll(s2) — возвращает true, если s2 является подмножеством s1. 
(s2 является подмножеством s1, если множество s1 содержит все элементы s2.);   
s1.addAll(s2) — преобразует s1 в объединение s1 и s2. (Объединение двух множеств 
— это множество, содержащее все элементы, содержащиеся в любом множестве.);   
s1.retainAll(s2) — преобразует s1 в пересечение s1 и s2. (Пересечение двух 
множеств — это множество, содержащее только элементы, общие для обоих множеств.);  
s1.removeAll(s2) — преобразует s1 в (асимметричную) разность наборов s1 и s2. 
(Например, разность множества s1 минус s2 — это множество, содержащее все 
элементы, найденные в s1, но не в s2.)  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>


### 30. Зависит ли множество, как структура данных, от имплементации?   Обоснуйте ответ.
**Ответ.**  
Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает 
хранение двух одинаковых элементов. Формально говоря, термин «множество» и так 
обозначает совокупность различных элементов, очень важно, что именно различных 
элементов, так как это главное свойство Set. С учетом такого определения, 
пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие 
«множество» потеряло свой строгий смысл касательно уникальности элементов, входящих 
в него, поэтому все же уточняйте отдельно данное свойство множества.  

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. 
Сложность выполнения основных операций в TreeSet lg N. HashSet использует для 
хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet 
в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не 
поддерживает упорядоченное хранение элементов и обеспечивает временную сложность 
выполнения операций аналогично HashMap.  
**Источник.**<https://habr.com/ru/post/162017/>


### 31. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?  
**Ответ.**  
HashSet – неотсортированная и неупорядоченная коллекция, для вставки элемента
используются методы hashCode() и equals(…).  
Чем эффективней реализован метод hashCode(), тем эффективней работает
коллекция.  
HashSet используется в случае, когда порядок элементов не важен, но важно чтобы
в коллекции все элементы были уникальны.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 32. Какие соглашения установлены для переопределения метода hashCode()?  
**Ответ.**  
* вызов метода hashCode один и более раз над одним и тем же объектом должен 
возвращать одно и то же хэш-значение, при условии, что поля объекта, участвующие 
в вычислении значения, не изменялись.  
* вызов метода hashCode над двумя объектами должен всегда возвращать одно и то 
же число, если эти объекты равны (вызов ме-тода equals для этих объектов 
возвращает true).
* вызов метода hashCode над двумя неравными между собой объектами должен 
возвращать разные хэш-значения. Хотя это требование и не является обязательным, 
следует учитывать, что его выполнение положительно повлияет на производительность 
работы хэш-таблиц.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 33. Почему недостаточно переопределить один только метод hashCode()?  
**Ответ.**  
Это объясняется коллизией, т.е. значение хэш-функции ограничено и имеет меньшее значение
чем количество объектов. Есть вероятность получения одного и того значения хэш-функции 
над двумяразными объектами.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 34. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?  
```java
@Override
public int hashCode() {
return 22;
}
```
**Ответ.**  
Это допустимый метод, поскольку он гарантирует, что одинаковые объекты
имеют один и тот же хеш-код. Но он ужасно плохой, потому что каждый объект
имеет один и тот же хеш-код. Таким образом, все объекты хранятся в одном
и том же блоке, и хеш-таблица превращается в связанный список. Программа,
которая должна была бы выполняться за линейное время, вместо этого будет
работать квадратичное время. Для больших хеш-таблиц это фактически разница
между работоспособностью и неработоспособностью.  


### 35. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?  
```java
class Entity {
    private int value;
    
    public int getValue() {
        return value;
    }
    
    public void setValue(int value) {
        this.value = value;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Entity entity = (Entity) obj;
        return value == entity.value;
    }
    
    @Override
    public int hashCode() {
        int result = 1;
        result = result * 31 + value;
        return result;
    }
}
```
**Ответ.**  
Умножение делает результат зависящим от порядка полей и дает
гораздо лучшую хеш-функцию, если класс имеет несколько аналогичных полей.
Например, если опустить умножение из хеш-функции для String, все
анаграммы будут иметь одинаковые хеш-коды. Значение 31 выбрано потому,
что оно является нечетным простым числом. Если бы оно было четным и умножение
приводило к переполнению, то происходила бы потеря информации,
потому что умножение на 2 эквивалентно сдвигу. Преимущество использования
простых чисел менее понятно, но это традиционная практика. Приятным
свойством 31 является то, что умножение можно заменить сдвигом и вычитанием
для повышения производительности на некоторых архитектурах: 31*i
== (i<<5) -i. Современные виртуальные машины выполняют оптимизацию
такого вида автоматически.


### 36. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?  
**Ответ.**  
Для хранения объектов использует бинарное дерево.
При добавлении объекта в дерево он сразу же размещается в необходимую позицию
с учетом сортировки.  
Сортировка происходит благодаря тому, что все добавляемые элементы реализуют
интерфейсы Comparator и Comparable.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 37. В чем заключается актуальность внешнего компаратора?  
**Ответ.**  
Метод Comparator <? super E> comparator() класса TreeSet возвращает объект
Comparator, используемый для сортировки объектов множества или null, если
выполняется обычная сортировка.  Внешней компаратор актуален тем, что можно организовать 
сортировку по необходимому критерию, а не по natural sort.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 38. Дана следующая коллекция:
```java
Collection<Entity> entities = …;
```
### Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.
**Ответ.**  
```java
Set<Byn> byns = new HashSet<>(entities);
```


### 39. Какую математическую сущность моделирует интерфейс List?  
**Ответ.**  
Последовательность - совокупность элементов, которые можно представить в виде: 
an,an+1...an-1,an  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 40. Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?  
**Ответ.**  
Интерфейс List сохраняет последовательность добавления элементов и позволяет
осуществлять доступ к элементу по индексу.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 41. Может ли имплементация интерфейса List содержать одинаковые элементы?   Обоснуйте ответ.
**Ответ.**
Список МОЖЕТ содержать повторяющиеся элементы.  
Ключевая особенность в том, что элементы расположены один за одним и имеют свой индекс.
Список в Java — это просто динамический массив, размер которого растет вместе с 
данными. Вы знаете, что массив представляет собой набор данных, и в массиве вы 
можете иметь повторяющееся значение, поэтому список позволяет дублировать элемент.  
**Источник.** <https://www.quora.com/Why-does-list-allow-duplicate-elements-in-Java>  
