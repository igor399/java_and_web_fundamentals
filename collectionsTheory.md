### 1. Дайте неформальное определение контейнера.
**Ответ.**    
Контейнер — это класс или структура данных, чьи экземпляры являются коллекциями 
других объектов. Другими словами, они хранят объекты упорядоченно, в соответствии 
с определенными правилами доступа.  
**Источник.** <https://en.wikipedia.org/wiki/Container_(abstract_data_type)>


### 2. Дайте определение коллекции в java.
**Ответ.**  
Коллекция, иногда называемая контейнером, — это просто объект, объединяющий
несколько элементов в единое целое. Коллекции используются для хранения,
извлечения, обработки и передачи агрегированных данных. Как правило, они
представляют собой элементы данных, образующие естественную группу, например
покерную комбинацию (набор карт), почтовую папку (набор писем) или телефонный
справочник (сопоставление имен с номерами телефонов). Если вы использовали язык
программирования Java или любой другой язык программирования, вы уже знакомы с
коллекциями.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 3. Какой имеется в java контейнер, отличный от коллекций?  Дайте ему определение.
**Ответ.**    
Массив — это объект-контейнер, который содержит фиксированное количество значений
одного типа. Длина массива устанавливается при создании массива. После создания
его длина фиксируется.  
**Источник.**<https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html>


### 4. Дайте определение Collections framework?
**Ответ.**  
Collections framework - это унифицированная архитектура для представления и
манипулирования коллекциями.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 5. Какие разделы содержит Collections framework?  Определите их, и для чего они предназначены?
**Ответ.**  
* Interfaces: это абстрактные типы данных, представляющие коллекции. Интерфейсы
  позволяют управлять коллекциями независимо от деталей их представления. В
  объектно-ориентированных языках интерфейсы обычно образуют иерархию.
* Реализации (Implementations): это конкретные реализации интерфейсов коллекций.
  По сути, это повторно используемые структуры данных.
* Алгоритмы : Это методы, которые выполняют полезные вычисления, такие как поиск
  и сортировка, над объектами, которые реализуют интерфейсы коллекций. Алгоритмы
  называются полиморфными: то есть один и тот же метод может использоваться во
  многих различных реализациях соответствующего интерфейса коллекции. По сути,
  алгоритмы — это повторно используемые функции.  
  **Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 6. В чем преимущества использования Collections Framework
**Ответ.**  
* Сокращает усилия по программированию: Предоставляя полезные структуры данных и
  алгоритмы, Collections Framework позволяет вам сконцентрироваться на важных частях
  вашей программы, а не на низкоуровневой «сантехнике», необходимой для ее работы.
  Упрощая взаимодействие между несвязанными API, Java Collections Framework освобождает
  вас от написания объектов адаптера или кода преобразования для подключения API.

* Увеличивает скорость и качество программы: эта структура коллекций обеспечивает
  высокопроизводительные и высококачественные реализации полезных структур данных
  и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому
  программы можно легко настраивать, переключая реализации коллекций. Поскольку
  вы освобождаетесь от рутинной работы по написанию собственных структур данных,
  у вас появляется больше времени для улучшения качества и производительности программ.

* Обеспечивает взаимодействие между несвязанными API: интерфейсы коллекций —
  это язык, с помощью которого API передают коллекции туда и обратно. Если мой
  API-интерфейс сетевого администрирования предоставляет набор имен узлов, а ваш
  инструментарий GUI ожидает набор заголовков столбцов, наши API-интерфейсы будут
  беспрепятственно взаимодействовать, даже если они были написаны независимо друг
  от друга.

* Сокращает усилия по изучению и использованию новых API: многие API естественным
  образом принимают коллекции на входе и предоставляют их на выходе. Раньше у
  каждого такого API был небольшой суб-API, предназначенный для управления его
  коллекциями. Между этими специальными API-интерфейсами коллекций было мало
  согласованности, поэтому вам приходилось изучать каждый из них с нуля, и при
  их использовании было легко сделать ошибки. С появлением стандартных интерфейсов
  коллекций проблема ушла.

* Сокращает усилия по разработке новых API: это обратная сторона предыдущего
  преимущества. Дизайнерам и разработчикам не нужно изобретать велосипед каждый
  раз, когда они создают API, основанный на коллекциях; вместо этого они могут
  использовать стандартные интерфейсы коллекций.

* Способствует повторному использованию программного обеспечения: новые структуры
  данных, соответствующие стандартным интерфейсам коллекций, по своей природе допускают
  повторное использование. То же самое касается новых алгоритмов, работающих с
  объектами, реализующими эти интерфейсы.  
  **Источник.**<https://docs.oracle.com/javase/tutorial/collections/intro/index.html>


### 7. Является ли антипаттерном следующее объявление ссылки на коллекцию?  Если да, то как называется антипаттерн и исправьте объявление ссылки.
```java
Collection collection;
```
**Ответ.**    
Является грубым антипаттерном. Ссылка на коллекцию объявлена без параметризации, те
как raw-type или сырой тип. Нарушается типобезопасность.
```java
// Параметризованный тип коллекции - безопасно
private final Collection<Stamp> stamps = ... ;
```
**Источник.** Джошуа Блох, Java. Эффективное программирование. Третье издание.


### 8. К каким негативным последствиям может привести использование `raw types`?   Приведите пример.
**Ответ.**    
Мы получаем предгенерированное поведение с необработанными типами. Таким образом,
необработанный тип Список принимает Объект и может содержать элемент любого типа
данных . Это может привести к проблемам безопасности типов, когда мы смешиваем
параметризованные и необработанные типы.  
Посмотрим на это, создав некоторый код, который создает экземпляр List перед
передачей его методу, который принимает необработанный тип List и добавляет к
нему целое число:
```java
public void methodA() {
    List parameterizedList = new ArrayList<>();
    parameterizedList.add("Hello Folks");
    methodB(parameterizedList);
}

public void methodB(List rawList) { // raw type!
    rawList.add(1);
}
```  
Код компилируется (с предупреждением), и Integer добавляется в необработанный
тип List при выполнении. List, который был передан в качестве аргумента,
теперь содержит Строку и Целое число.  
Отсутствие безопасности типов в необработанном типе имеет причинно-следственные
последствия, которые могут привести к исключениям во время выполнения.  
Изменим предыдущий пример так, чтобы method получал элемент в позиции индекса 1
нашего List:
```java
public void methodA() {
        List parameterizedList = new ArrayList<>();
        parameterizedList.add("Hello Folks");
        methodB(parameterizedList);
        String s = parameterizedList.get(1);
        }

public void methodB(List rawList) {
        rawList.add(1);
        }
```  
Код компилируется (с тем же предупреждением) и при выполнении выдает ClassCastException.
Это происходит, когда метод get(int index) возвращает Целое число, которое не может
быть присвоено переменной типа String.  
**Источник.** <https://javascopes.com/raw-types-java-d9ab869d/>


### 9. Почему допускаются raw types с коллекциями?
**Ответ.**    
Есть всего три случая, когда использовать обобщенный тип без параметра правильно:
• Целевая версия Java < 5.0 (2002 год и ранее – вряд ли это ваш случай);
• В литерале класса. List<String>.class не сработает, нужно писать List.class;
• В операторе instanceof. Вместо instanceof Set<Integer> должно быть instanceof Set.  
**Источник.**<https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/>


### 10. Какое главное назначение раздела Интерфейсы?   Другими словами, если известен интерфейс коллекции, то что это дает программисту?
**Ответ.**    
Основные интерфейсы коллекций инкапсулируют различные типы коллекций.
Эти интерфейсы позволяют управлять коллекциями независимо от деталей их
представления. Основные интерфейсы коллекций являются основой Java Collections
Framework.  
Интерфейсы позволяют манипулировать коллекциями независимо от деталей
конкретной реализации, реализуя тем самым принцип полиморфизма.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 11. Какое главное назначение раздела Имплементации?  Другими словами, если известна имплементация, то что это дает программисту?
**Ответ.**    
Реализации (Implementations) — это объекты данных, используемые для хранения коллекций, которые
реализуют интерфейсы.   
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 12. Приведите иерархию интерфейсов коллекций.
**Ответ.**
* interface Collection extends Iterable;
* interface List, Queue, Set extends Collection;
* interface Deque extends Queue;
* interface SortedSet extends Set;
* interface NavigableSet extends SortedSet;

* interface SortedMap extends Map;
* interface NavigableMap extends SortedMap;  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html>


### 13. Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?
### Какой способ является более подходящим для прохода по коллекции до версии java 8?
### Приведите идиомы для следующей коллекции:
```java
Collection<Entity> entities = …;
```
**Ответ.**    
Существует два способа обхода коллекций: (1) с конструкцией for-each и (2) с
использованием итераторов.  
Цикл по коллекции (for-each, официально известный как "расширенный
цикл for") решает все указанные проблемы. Он избавляет программистов от
путаницы и возможностей для внесения ошибок, полностью скрывая итератор
или индексную переменную.

for-each Construct:
```java
// Предпочтительная идиома обхода элементов коллекции или массива
for (Entity entity : entities) {
    System.out.println(entity);
}
```
Iterators:
```java
// Идиома обхода в случае необходимости доступа к итератору
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); ){
    System.out.println(it.next());
}
```
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html>

### 14. Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?
### Какой метод этого интерфейса обеспечивает данную возможность?
**Ответ.**
```java
interface Iterable<T>{
 Iterator<T> iterator(); // возвращает итератор по множеству элементов T
}
```   
Интерфейс Iterator<E> используется для доступа к элементам коллекции.  
Iterator<E> iterator() – возвращает итератор.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 15. Что такое итератор?
**Ответ.**    
Итератор – это объект, который позволяет осуществлять обход коллекции и при
желании удалять избранные элементы.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 16. Дана коллекция из n элементов. Сколько в ней существует возможных позиций курсора итератора?
**Ответ.**    
Итератор для списков, который позволяет программисту перемещаться по списку в
любом направлении, изменять список во время итерации и получать текущую позицию
итератора в списке. A ListIterator не имеет текущего элемента; его позиция курсора
всегда находится между элементом, который будет возвращен вызовом, previous()и
элементом, который будет возвращен вызовом next(). Итератор для списка длины
nимеет n+1возможные позиции курсора.  
**Источник.**<https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ListIterator.html>


### 17. Какие методы объявлены в интерфейсе Iterator<E>?   Охарактеризуйте их.
**Ответ.**
* boolean hasNext(): возвращает true при наличии следующего элемента, а в
  случае его отсутствия возвращает false. Итератор при этом остается
  неизменным;
* Object next(): возвращает объект, на который указывает итератор, и
  передвигает текущий указатель на следующий итератор, предоставляя доступ
  к следующему элементу. Если следующий элемент коллекции отсутствует, то
  метод next() генерирует исключение;
* void remove(): удаляет объект, возвращенный последним вызовом метода next();  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 18. В каких случаях следует явно использовать итератор вместо for-each?
**Ответ.**    
Используйте Iterator вместо for-each если вам необходимо удалить текущий
элемент.
* Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove;
* Также конструкция for-each не применима для фильтрации.  
  **Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 19. Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity.
### Приведите идиому удаления элементов этой коллекции.
**Ответ.**
```java
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); ){
    if (it.next().isRemoved()){ 
        it.remove();
    }
}
```


### 20. Какие группы методов (или операций) объявлены в интерфейсе Collection (до java 8)?   Какие методы входят в каждую группу?
**Ответ.**
* boolean equals(Object o);
* int size(): возвращает количество элементов в коллекции;
* boolean isEmpty(): возвращает true, если коллекция пуста;
* boolean contains(Object element): возвращает true, если коллекция
  содержит элемент element;
* boolean add(E element): добавляет element к вызывающей коллекции и
  возвращает true, если объект добавлен, и false, если element уже
  элемент коллекции;
* boolean remove(Object element): удаляет element из коллекции;
* Iterator<E> iterator(): возвращает итератор
* boolean containsAll(Collection<?> c): возвращает true, если коллекция
  содержит все элементы из c;
* boolean addAll(Collection<? extends E> c): добавляет все элементы
коллекции к вызывающей коллекции;  
boolean removeAll(Collection<?> c): удаление всех элементов данной
  коллекции, которые содержаться в c;
* boolean retainAll(Collection<?> c): удаление элементов данной
  коллекции, которые не содержаться в коллекции c;
* void clear(): удаление всех элементов;
* Object[] toArray(): копирует элементы коллекции в массив объектов;
* <T> T[] toArray(T[] a): возвращает массив, содержащий все элементы коллекции;  
* Iterator<T> iterator(): возвращает итератор по множеству элементов T.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 21. В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?
**Ответ.**
* Object[] toArray(): копирует элементы коллекции в массив объектов;
* <T> T[] toArray(T[] a): возвращает массив, содержащий все элементы коллекции;  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 22. В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”. Как это понимать?
**Ответ.**    
Некоторые методы интерфейса Collection могут быть не реализованы в
подклассах (нет необходимости их реализовывать). В этом случае метод генерирует
java.lang.UnsupportedOperationException (подкласс RuntimeException).  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 23. Какую математическую сущность моделирует интерфейс Set?
**Ответ.**    
Множество ─ коллекция без повторяющихся элементов. Моделирует математическую
абстракцию множества.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 24. Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?
**Ответ.**    
Интерфейс Set<E> содержит методы, унаследованные Collection<E> и добавляет запрет
на дублирующиеся элементы. Set также добавляет соглашение на поведение методов
equals и hashCode, позволяющих сравнивать множества даже если их реализации
различны. Два множества считаются равными, если они содержат одинаковые элементы.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 25. Может ли множество содержать null элемент?
**Ответ.**    
HashSet можно вставить лишь одно значение null (уникальность элементов),
TreeSet — только для первого элемента.  
**Источник.**<https://savepearlharbor.com/?p=164027>


### 26. Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?   Если нет, то есть ли у множества итератор?
**Ответ.**    
Set — это неупорядоченное множество и не поддерживает порядок элементов.  
Интерфейс NavigableSet добавляет возможность перемещения, "навигации" по
отсортированному множеству.   
Возвращают итераторы коллекции в порядке возрастания и убывания элементов
соответственно:
* Iterator<E> iterator();
* Iterator<E> descendingIterator();
* NavigableSet<E> descendingSet();  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 27. Как получить элемент множества по индексу?
**Ответ.**    
Мы можем получить элементы по индексу в HashSet тремя различными способами:
1. Использование массива;
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Converting HashSet to Array
        String[] Geeks = GFG.toArray(new String[GFG.size()]);
  
        // Accessing elements by index
        System.out.println("Element at index 3 is: "
                           + Geeks[3]);
    }
}
```
2. Использование цикла for;
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Iterator declaration
        int currentIndex = 0;
  
        // Desired Index
        int desiredIndex = 3;
        
        for (String element :GFG) { 
          // Implementing for loop
  
            if (currentIndex == desiredIndex)
            {
                System.out.println("Element at index 3 is: "+ element);
                break;
            }
            currentIndex++;
        }
    }
}
```

3. Использование списка массивов;
```java
class GFG {
    public static void main(String[] args)
    {
  
        // Declare HashSet using Set Interface
        Set<String> GFG = new HashSet<String>();
  
        // Add elements into HashSet using add()
        GFG.add("Welcome");
        GFG.add("To");
        GFG.add("Geeks");
        GFG.add("For");
        GFG.add("Geek");
  
        // Displaying HashSet
        System.out.println("HashSet contains: " + GFG);
  
        // Notice the order of elements may be different
        // than insertion
  
        // Converting HashSet to ArrayList
        List<String> list = new ArrayList<String>(GFG);
  
        System.out.println("Element at index 3 is: "
                           + list.get(3));
    }
}
```  
**Источник.**<https://www.geeksforgeeks.org/how-to-get-elements-by-index-from-hashset-in-java/>


### 28. Как реализован метод add() во множестве?
**Ответ.**  
boolean add(E element); //добавляет element к вызывающему множеству и
возвращает true, если объект добавлен, и false, если element уже элемент
множества.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 29. Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?   Какие методы добавились?
**Ответ.**    
Bulk group:  
s1.containsAll(s2) — возвращает true, если s2 является подмножеством s1.
(s2 является подмножеством s1, если множество s1 содержит все элементы s2.);   
s1.addAll(s2) — преобразует s1 в объединение s1 и s2. (Объединение двух множеств
— это множество, содержащее все элементы, содержащиеся в любом множестве.);   
s1.retainAll(s2) — преобразует s1 в пересечение s1 и s2. (Пересечение двух
множеств — это множество, содержащее только элементы, общие для обоих множеств.);  
s1.removeAll(s2) — преобразует s1 в (асимметричную) разность наборов s1 и s2.
(Например, разность множества s1 минус s2 — это множество, содержащее все
элементы, найденные в s1, но не в s2.)  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html>


### 30. Зависит ли множество, как структура данных, от имплементации?   Обоснуйте ответ.
**Ответ.**  
Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает
хранение двух одинаковых элементов. Формально говоря, термин «множество» и так
обозначает совокупность различных элементов, очень важно, что именно различных
элементов, так как это главное свойство Set. С учетом такого определения,
пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие
«множество» потеряло свой строгий смысл касательно уникальности элементов, входящих
в него, поэтому все же уточняйте отдельно данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.
Сложность выполнения основных операций в TreeSet lg N. HashSet использует для
хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet
в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не
поддерживает упорядоченное хранение элементов и обеспечивает временную сложность
выполнения операций аналогично HashMap.  
**Источник.**<https://habr.com/ru/post/162017/>


### 31. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?
**Ответ.**    
HashSet – неотсортированная и неупорядоченная коллекция, для вставки элемента
используются методы hashCode() и equals(…).  
Чем эффективней реализован метод hashCode(), тем эффективней работает
коллекция.  
HashSet используется в случае, когда порядок элементов не важен, но важно чтобы
в коллекции все элементы были уникальны.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 32. Какие соглашения установлены для переопределения метода hashCode()?
**Ответ.**
* вызов метода hashCode один и более раз над одним и тем же объектом должен
  возвращать одно и то же хэш-значение, при условии, что поля объекта, участвующие
  в вычислении значения, не изменялись.
* вызов метода hashCode над двумя объектами должен всегда возвращать одно и то
  же число, если эти объекты равны (вызов ме-тода equals для этих объектов
  возвращает true).
* вызов метода hashCode над двумя неравными между собой объектами должен
  возвращать разные хэш-значения. Хотя это требование и не является обязательным,
  следует учитывать, что его выполнение положительно повлияет на производительность
  работы хэш-таблиц.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 33. Почему недостаточно переопределить один только метод hashCode()?
**Ответ.**    
Это объясняется коллизией, т.е. значение хэш-функции ограничено и имеет меньшее значение
чем количество объектов. Есть вероятность получения одного и того значения хэш-функции
над двумяразными объектами.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 34. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?
```java
@Override
public int hashCode() {
return 22;
}
```
**Ответ.**    
Это допустимый метод, поскольку он гарантирует, что одинаковые объекты
имеют один и тот же хеш-код. Но он ужасно плохой, потому что каждый объект
имеет один и тот же хеш-код. Таким образом, все объекты хранятся в одном
и том же блоке, и хеш-таблица превращается в связанный список. Программа,
которая должна была бы выполняться за линейное время, вместо этого будет
работать квадратичное время. Для больших хеш-таблиц это фактически разница
между работоспособностью и неработоспособностью.


### 35. Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?
```java
class Entity {
    private int value;
    
    public int getValue() {
        return value;
    }
    
    public void setValue(int value) {
        this.value = value;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Entity entity = (Entity) obj;
        return value == entity.value;
    }
    
    @Override
    public int hashCode() {
        int result = 1;
        result = result * 31 + value;
        return result;
    }
}
```
**Ответ.**    
Умножение делает результат зависящим от порядка полей и дает
гораздо лучшую хеш-функцию, если класс имеет несколько аналогичных полей.
Например, если опустить умножение из хеш-функции для String, все
анаграммы будут иметь одинаковые хеш-коды. Значение 31 выбрано потому,
что оно является нечетным простым числом. Если бы оно было четным и умножение
приводило к переполнению, то происходила бы потеря информации,
потому что умножение на 2 эквивалентно сдвигу. Преимущество использования
простых чисел менее понятно, но это традиционная практика. Приятным
свойством 31 является то, что умножение можно заменить сдвигом и вычитанием
для повышения производительности на некоторых архитектурах: 31*i
== (i<<5) -i. Современные виртуальные машины выполняют оптимизацию
такого вида автоматически.


### 36. Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?
**Ответ.**    
Для хранения объектов использует бинарное дерево.
При добавлении объекта в дерево он сразу же размещается в необходимую позицию
с учетом сортировки.  
Сортировка происходит благодаря тому, что все добавляемые элементы реализуют
интерфейсы Comparator и Comparable.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 37. В чем заключается актуальность внешнего компаратора?
**Ответ.**    
Метод Comparator <? super E> comparator() класса TreeSet возвращает объект
Comparator, используемый для сортировки объектов множества или null, если
выполняется обычная сортировка.  Внешней компаратор актуален тем, что можно организовать
сортировку по необходимому критерию, а не по natural sort.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 38. Дана следующая коллекция:
```java
Collection<Entity> entities = …;
```
### Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.
**Ответ.**
```java
Set<Byn> byns = new HashSet<>(entities);
```


### 39. Какую математическую сущность моделирует интерфейс List?
**Ответ.**    
Последовательность - совокупность элементов, которые можно представить в виде:
an,an+1...an-1,an  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 40. Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?
**Ответ.**  
Интерфейс List сохраняет последовательность добавления элементов и позволяет
осуществлять доступ к элементу по индексу.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 41. Может ли имплементация интерфейса List содержать одинаковые элементы?   Обоснуйте ответ.
**Ответ.**  
Список МОЖЕТ содержать повторяющиеся элементы.  
Ключевая особенность в том, что элементы расположены один за одним и имеют свой индекс.
Список в Java — это просто динамический массив, размер которого растет вместе с
данными. Вы знаете, что массив представляет собой набор данных, и в массиве вы
можете иметь повторяющееся значение, поэтому список позволяет дублировать элемент.  
**Источник.** <https://www.quora.com/Why-does-list-allow-duplicate-elements-in-Java>


### 42. Какие группы методов увеличились в интерфейсе List по сравнению с интерфейсом Collection?   Какие методы добавились?
**Ответ.**  
Basic:
* Позиционный доступ — манипулирует элементами на основе их числового положения
  в списке. Сюда входят такие методы, как get, set, add, addAll и remove.

* Поиск — ищет указанный объект в списке и возвращает его числовую позицию.
  Методы поиска включают indexOf и lastIndexOf.

* Итерация — расширяет семантику Iterator, чтобы использовать преимущества
  последовательного характера списка. Методы listIterator обеспечивают такое поведение.

Bulk:
* Range-view — Метод подсписка выполняет произвольные операции с диапазоном в списке.  
  **Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html>


### 43. Влияют ли изменения внесенные в последовательность, возвращаемый методом subList(), на исходную последовательность?
**Ответ.**    
Возвращает представление части этого списка между указанным fromIndex, включительно,
и toIndex, исключая. (Если fromIndex и toIndex равны, возвращаемый список пуст.)
Возвращаемый список поддерживается этим списком, поэтому неструктурные изменения
в возвращаемом списке отражаются в этом списке, и наоборот. Возвращаемый список
поддерживает все необязательные операции списка. Т.е. все операции с методом sublist()
воздействуют на исходный лист.  
**Источник.**<https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html>


### 44. Дана следующая последовательность:
```java
List<Entity> entities = …;
```
#### Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента [fromIndex; toIndex).
**Ответ.**
```java
entities.subList(fromIndex, toIndex).clear();
```
**Источник.**<https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html#subList(int,int)>


### 45. Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:
```java
List<Entity> entities = …;
Entity cmpEntity = …;
```
### Приведите идиому для выполнения метода void doAction() класса Entity со всеми элементами последовательности entities, которые совпадают с элементом cmpEntity. Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.
**Ответ.**
```java
void doAction(List<Entity> entities, Entity cmpEntity){
    for(ListIterator<Entity> it = entities.listiterator(); it.hasNext();){
        if (val == null ? it.next() == null : val.equals(it.next())) {
        return true;
        }
    }
}
```
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html>


### 46. Какую математическую сущность моделирует интерфейс Queue?
**Ответ.**  
Очередь, предназначенная для размещения элемента перед его обработкой.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 47. Какое основное свойство всех имплементаций интерфейса Queue, т.е. что их объединяет независимо от имплементации?
**Ответ.**  
Очереди обычно, но не обязательно, упорядочивают элементы в порядке FIFO
(первым поступил – первым обслужен). Исключениями являются приоритетные очереди,
которые упорядочивают элементы в соответствии с их значениями). Какой бы порядок
ни использовался, главой очереди является элемент, который будет удален вызовом
remove или poll. В очереди FIFO все новые элементы вставляются в конец очереди.
Другие виды очередей могут использовать другие правила размещения. Каждая
реализация Queue должна указывать свои свойства упорядочения.  
**Источник.** <https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html>


### 48. Какие группы методов увеличились в интерфейсе Queue по сравнению с интерфейсом Collection?   Какие методы добавились?
**Ответ.**  
Помимо основных операций сбора, очереди предоставляют дополнительные операции
вставки, удаления и проверки.

* E element(); // возвращает, но не удаляет головной элемент очереди.
* boolean offer(E o); //добавляет в конец очереди новый элемент и возвращает
  true, если вставка удалась.
* E peek(); // возвращает первый элемент очереди, не удаляя его.
* E poll(); // возвращает первый элемент и удаляет его из очереди.
* E remove(); // возвращает и удаляет головной элемент очереди.

Класс AbstractQueue – реализует методы интерфейса Queue:
* size();
* offer(Object o);
* peek();
* poll();
* iterator().  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.


### 49. Какую математическую сущность моделирует интерфейс Deque?
**Ответ.**  
Двусторонняя очередь — это линейный набор элементов, который поддерживает вставку
и удаление элементов в обеих конечных точках.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html>


### 50. Какое основное свойство всех имплементаций интерфейса Deque, т.е. что их объединяет независимо от имплементации?
**Ответ.**  
Интерфейс Deque представляет собой более богатый абстрактный тип данных, чем
Stack и Queue, поскольку он одновременно реализует и стеки, и очереди. Интерфейс
Deque определяет методы для доступа к элементам на обоих концах экземпляра Deque.
Предоставляются методы для вставки, удаления и проверки элементов. Предопределенные
классы, такие как ArrayDeque и LinkedList, реализуют интерфейс Deque.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html>


### 51. Какие методы определяет Deque в добавок к методам унаследованным от Queue?
**Ответ.**  
Insert:  
Методы addfirst и offerFirst вставляют элементы в начало экземпляра Deque.
Методы addLast и offerLast вставляют элементы в конец экземпляра Deque. Когда
емкость экземпляра Deque ограничена, предпочтительными являются методы offerFirst
и offerLast, поскольку addFirst может не выдать исключение, если он заполнен.  
Remove:  
Методы removeFirst и pollFirst удаляют элементы из начала экземпляра Deque. Методы
removeLast и pollLast удаляют элементы с конца. Методы pollFirst и pollLast возвращают
значение null, если Deque пуст, тогда как методы removeFirst и removeLast вызывают
исключение, если экземпляр Deque пуст.  
Retrieve:  
Методы getFirst и peekFirst извлекают первый элемент экземпляра Deque. Эти методы
не удаляют значение из экземпляра Deque. Точно так же методы getLast и peekLast
извлекают последний элемент. Методы getFirst и getLast вызывают исключение, если
экземпляр очереди пуст, тогда как методы peekFirst и peekLast возвращают NULL.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html>


### 52. Верно ли утверждение, что Queue всегда обрабатывает элемента в порядке FIFO?
**Ответ.**  
Очереди обычно, но не обязательно, упорядочивают элементы в порядке FIFO (первым
поступил – первым обслужен). Исключениями являются приоритетные очереди, которые
упорядочивают элементы в соответствии с их значениями. Какой бы порядок ни
использовался, главой очереди является элемент, который будет удален вызовом
remove или poll. В очереди FIFO все новые элементы вставляются в конец очереди.
Другие виды очередей могут использовать другие правила размещения. Каждая
реализация Queue должна указывать свои свойства упорядочения.  
**Источник.**<https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Queue.html>


### 53. Какой элемент независимо от упорядочения Queue будет удален методами remove и poll?
**Ответ.**    
Методы remove и poll удаляют и возвращают заголовок очереди. Какой именно элемент
будет удален, зависит от политики упорядочивания очереди. Методы remove и poll
отличаются по своему поведению только тогда, когда очередь пуста. В этих
обстоятельствах remove выдает исключение NoSuchElementException, а poll возвращает
значение null.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html>


### 54. Зачем в интерфейсе Queue метод poll, когда есть remove?
**Ответ.**    
Методы remove и poll отличаются по своему поведению только тогда, когда очередь
пуста. В этих обстоятельствах remove выдает исключение NoSuchElementException, а
poll возвращает значение null.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html>


### 55. Какую математическую сущность моделирует интерфейс Map?
**Ответ.**  
Карта — это объект, который сопоставляет ключи со значениями. Карта не может
содержать повторяющиеся ключи: каждый ключ может соответствовать не более чем
одному значению. Он моделирует абстракцию математической функции.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html>


### 56. Какое основное свойство всех имплементаций интерфейса Map, т.е. что их объединяет независимо от имплементации?
**Ответ.**  
Интерфейс Map работает с наборами пар объектов «ключ-значение».  
Все ключи в картах уникальны.  
Уникальность ключей определяет реализация метода equals(…).  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html>


### 57. Реализует ли Map интерфейс Collection?
**Ответ.**  
Следует отметить, что в отличие от других интерфейсов, которые представляют
коллекции, интерфейс Map НЕ расширяет интерфейс Collection.


### 58. Какую структуру данных представляет собой совокупность: ключей, значений, пар ключ-значение, любой имплементации Map?
**Ответ.**  
Cовокумность ключей - это множество;  
Совокупность значений - это любая имплементация интерфейса Collection (чаще всего List);
Совокупность пар ключ-значение - это множество;


### 59. Какие группы операций определены в интерфейсе Map?
**Ответ.**    
Map Interface Basic Operations:  
Основные операции Map (put, get, containsKey, containsValue, size, isEmpty) ведут
себя точно так же, как их аналоги в Hashtable.  
Map Interface Bulk Operations:  
Операция clear  делает именно то, что вы могли бы подумать: она удаляет все
сопоставления с карты. Операция putAll является аналогом Map операции addAll
интерфейса Collection. В дополнение к его очевидному использованию для сброса
одной Карты в другую, у него есть второе, более тонкое применение. Предположим,
что Map используется для представления набора пар атрибут-значение; операция
putAll в сочетании с конструктором преобразования Map обеспечивает удобный способ
реализации создания карты атрибутов со значениями по умолчанию.  
Collection Views:  
Методы просмотра коллекции позволяют просматривать карту как коллекцию тремя способами:
* keySet — Набор ключей, содержащихся в Карте.
* values - Коллекция значений, содержащихся в карте. Эта коллекция не является набором,
  так как несколько ключей могут сопоставляться с одним и тем же значением.
* entrySet - Набор пар ключ-значение, содержащихся в карте. Интерфейс карты
  предоставляет небольшой вложенный интерфейс с именем Map.Entry, тип элементов в этом наборе.  
  **Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html>


### 60. Какой интерфейс представляет мультикарту (multimap) в Collections Framework?
**Ответ.**  
Мультикарта похожа на карту, но она может сопоставлять каждый ключ с несколькими
значениями.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html>


### 61. Дана карта:
```java
Map<K, V> map = …;
```
### Приведите идиому для выполнения метода void doAction(K key, V value) со всеми элементами карты.
**Ответ.**
```java
void doAction(K key, V value){
    for(Map.Entry<K,V> entry : map.entrySet){
        System.out.println(entry.getKey() + "=>" + entry.getValue());
        }
      }
```
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html>


### 62. Дана карта:
```java
Map<K, V> map = …;
```
### в которой нет элементов со значением null.
### Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.
**Ответ.**
```java
V value = map.getKey();
if(value != null) {
    doAction(value);
}
```


### 63. Дана карта:
```java
Map<K, V> map = …;
```
### в которой есть элементы со значением null.
### Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.
**Ответ.**
```java
if(map.containsKey(Key)) {
    doAction(map.getKey());
}
```


### 64. Можно ли отрефакторить следующий код?   Если да, то сделайте это.
```java
Purchase purchase = new Purchase("meat", new Byn(100), 10);
for (Map.Entry<Purchase, WeekDay> entry: purchaseWeekDayMap.entrySet()) {
    if (entry.getKey().equals(purchase)) {
        System.out.println(entry.getKey());
        break;
    }
}
```
**Ответ.**


### 65. Что возвращает метод put интерфейса Map?
**Ответ.**  
V put(K k, V v) : помещает в коллекцию новый объект с ключом k и значением v.
Если в коллекции уже есть объект с подобным ключом, то он перезаписывается.
После добавления возвращает предыдущее значение для ключа k, если он уже был в
коллекции. Если же ключа еще не было в коллекции, то возвращается значение null.  
**Источник.**<https://metanit.com/java/tutorial/5.8.php#:~:text=V%20put>


### 66. Почему интерфейс Map не расширяет интерфейс Collection в Java Collections Framework?
**Ответ.**
Коллекция (List и Set) представляет собой совокупность некоторых элементов
(обычно экземпляров одного класса). Map - это совокупность пар "ключ"-"значение".
Соответственно некоторые методы интерфейса Collection нельзя использовать в Map.
Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления
элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет
элемент по заданному ключу.  
**Источник.**<https://parshinpn.ru/ru/blog/interview-java-collection-framework-part1>


### 67. Дайте определение понятию имплементация (Implementation) в контексте Collections Framework.
**Ответ.**  
Реализации — это объекты данных, используемые для хранения коллекций.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/implementations/index.html>


### 68. Какие виды имплементаций можно выделить?
**Ответ.**
* Реализации общего назначения — это наиболее часто используемые реализации,
  предназначенные для повседневного использования. Они сведены в таблицу под
  названием Реализации общего назначения.
* Реализации специального назначения предназначены для использования в особых
  ситуациях и демонстрируют нестандартные характеристики производительности,
  ограничения использования или поведение.
* Параллельные реализации предназначены для поддержки высокого параллелизма, как
  правило, за счет однопоточной производительности. Эти реализации являются
  частью пакета java.util.concurrent.
* Реализации-оболочки используются в сочетании с другими типами реализаций, часто
  универсальными, для предоставления дополнительных или ограниченных функций.
* Удобные реализации — это мини-реализации, обычно доступные через статические
  фабричные методы, которые предоставляют удобные и эффективные альтернативы
  универсальным реализациям для специальных коллекций (например, одноэлементных
  наборов).
* Абстрактные реализации — это скелетные реализации, которые упрощают создание
  пользовательских реализаций, описанных ниже в разделе «Реализации
  пользовательских коллекций». Продвинутая тема, это не особо сложно, но это
  нужно будет делать относительно небольшому количеству людей.  
  **Источник.**<https://docs.oracle.com/javase/tutorial/collections/implementations/index.html>


### 69. На что влияет выбор имплементации?
**Ответ.**    
Выбор имплементации может плохо повлиять на перфоманс.


### 70. Идиома создания пустой коллекции имеет следующий вид:
```java
SomeInterface<Entity> entities = new SuitableImplementation<>();
```
### Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?
**Ответ.**    
Это дает возможность изменять реализацию, меняя конструктор.
Реализация паттерна проектирования "фасад", т.е. использование методов интерфейса, а не
имплементации.


### 71. Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией.
### Результат представьте в виде таблицы:
|Interface|    Implementation|    Abstract Data Type|
|---|---|---|
**Ответ.**

|Interface|  Implementation  |    Abstract Data Type  |
|---------|------------------|------------------------|
|Set      |HashSet           |      set               |
|List     |ArrayList         |dynamic array (sequence)|
|Queue    |LinkedList        |    fifo (queue)        |
|Deque    |ArrayDeque        |    lifo (stack)        |
|Map      |HashMap           |      map               |


### 72. Приведите идиому создания очереди.
```java
Xxx<Integer> queue = ...;
```
### `Xxx` - это подходящий интерфейс. Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.
**Ответ.**
```java
public class QueueMain{
    public static void main(String[]args){
      Queue<Integer> queue = new LinkedList<>();
      queue.offer(9);
      queue.offer(8);
      queue.offer(7);
      queue.remove();
      queue.forEach(System.out::println);
    }
}
```
вывод:  
8
7


### 73. Приведите идиому создания стека.
```java
Xxx<Integer> stack = ...;
```
### `Xxx` - это подходящий интерфейс. Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.
**Ответ.**
```java
public class DequeMain {
  public static void main(String[] args) {
    Deque<Integer> stack = new ArrayDeque<>();
    stack.push(9);
    stack.push(8);
    stack.push(7);
    stack.pop();
    System.out.println(stack);
  }
}
```
вывод:  
[8, 9]


### 74. Когда целесообразно использовать реализацию TreeSet вместо HashSet?
**Ответ.**  
HashSet является более быстрым, т.к. использует более быстрые алгоритмы добавления.  
В HashSet можно добавлять литерал null в качестве элемента.  
HashSet использует equals() при добавлении, TreeSet использует compareTo().  
TreeSet - упорядоченное множество, HashSet - неупорядоченное.  
TreeSet более экономный с точки зрения использования памяти.  
TreeSet использует алгоритм красно-черного дерева.


### 75. Опишите неупорядоченные реализации Map.
**Ответ.**  
HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями
от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет
использовать null как в качестве ключа, так и значения. Так же как и Hashtable,
данная коллекция не является упорядоченной: порядок хранения элементов зависит
от хэш-функции.  
Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет
использовать null в качестве значения или ключа. Эта коллекция была реализована
раньше, чем Java Collection Framework, но в последствии была включена в его
состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной
(почти все методы помечены как synchronized).  
**Источник.**<https://habr.com/ru/post/237043/>


### 76. Опишите упорядоченные реализации Map.
**Ответ.**  
LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от
HashMap, порядок итерирования равен порядку добавления элементов. Данная
особенность достигается благодаря двунаправленным связям между элементами
(аналогично LinkedList).  
TreeMap — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap
является упорядоченной. По-умолчанию, коллекция сортируется по ключам с
использованием принципа "natural ordering", но это поведение может быть настроено
под конкретную задачу при помощи объекта Comparator, который указывается в
качестве параметра при создании объекта TreeMap.  
**Источник.**<https://habr.com/ru/post/237043/>


### 77. Чем отличается ArrayList и LinkedList?
**Ответ.**  
ArrayList внутри представляет собой массив, который может увеличиваться при его переполнении.
LinkedList - это список ссылок с двойным соединением.  
Производительность: для разных методов она разная. Например метод getIndex() при
использовании ArrayList выполняется за постоянное время. В LinkedList скорость срабатывания
прямопропорционально размеру этого списка.  
При всей схожести списков ArrayList и LinkedList существуют серьезные
отличия, которые необходимо учитывать при использовании коллекций в конкретных
задачах. Если необходимо осуществлять быструю навигацию по списку, то
следует применять ArrayList, так как перебор элементов в LinkedList
осуществляется на порядок медленнее. С другой стороны, если требуется часто
добавлять и удалять элементы из списка, то уже класс LinkedList обеспечивает
значительно более высокую скорость переиндексации. То есть если коллекция
формируется в начале процесса и в дальнейшем используется только
для доступа к информации, то применяется ArrayList, если же коллекция подвергается
изменениям на всем протяжении функционирования приложения, то выгоднее LinkedList.


### 78. Что такое вычислительная сложность операции (алгоритма)?
**Ответ.**  
Вычислительная сложность - функция зависимости объёма работы, которая выполняется
некоторым алгоритмом, от размера входных данных.


### 79. Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.
**Ответ.**  
List:  
ArrayList:
* add() – takes O(1) time; however, worst-case scenario, when a new array has to be created and all the elements copied to it, it's O(n)
* add(index, element) – on average runs in O(n) time
* get() – is always a constant time O(1) operation
* remove() – runs in linear O(n) time. We have to iterate the entire array to find the element qualifying for removal.
* indexOf() – also runs in linear time. It iterates through the internal array and checks each element one by one, so the time complexity for this operation always requires O(n) time.
* contains() – implementation is based on indexOf(), so it'll also run in O(n) time.

LinkedList:
* add() – appends an element to the end of the list. It only updates a tail, and therefore, it's O(1) constant-time complexity.
* add(index, element) – on average runs in O(n) time
* get() – searching for an element takes O(n) time.
* remove(element) – to remove an element, we first need to find it. This operation is O(n).
* remove(index) – to remove an element by index, we first need to follow the links from the beginning; therefore, the overall complexity is O(n).
* contains() – also has O(n) time complexity

Map:  
With the latest JDK versions, we're witnessing significant performance improvement
for Map implementations, such as replacing the LinkedList with the balanced tree
node structure in HashMap, and LinkedHashMap internal implementations. This shortens
the element lookup worst-case scenario from O(n) to O(log(n)) time during the
HashMap collisions.

Set:  
For HashSet, LinkedHashSet, and EnumSet, the add(), remove() and contains()
operations cost constant O(1) time thanks to the internal HashMap implementation.  
Likewise, the TreeSet has O(log(n)) time complexity for the operations listed in
the previous group. This is because of the TreeMap implementation. The time
complexity for ConcurrentSkipListSet is also O(log(n)) time, as it's based in
skip list data structure.  
For CopyOnWriteArraySet, the add(), remove() and contains() methods have O(n)
average time complexity.  
**Источник.**<https://www.baeldung.com/java-collections-complexity>


### 80. В чем разница между интерфейсами Comparable и Comparator?
**Ответ.**
Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки.  
Comparator - имплементится другими классами. Дает возможность отделить реализацию
сравнения от класса и сделать несколько реализаций сравнения по разным параметрам
для одного класса.


### 81. В чем разница между Iterator и ListIterator?
**Ответ.**
* Основное различие между Iterator и ListIterator заключается в том, что,
  являясь курсором, Iterator может перемещаться по элементам в коллекции только
  в прямом направлении. С другой стороны, ListIterator может перемещаться как в
  прямом, так и в обратном направлении.
* Используя итератор, вы не можете добавить какой-либо элемент в коллекцию. Но с
  помощью ListIterator вы можете добавлять элементы в коллекцию.
* Используя Iterator, вы не можете удалить элемент из коллекции, где, как вы
  можете удалить элемент из коллекции, используя ListIterator.
* Используя Iterator, вы можете просматривать все коллекции, такие как Map,
  List, Set. Но с помощью ListIteror вы можете проходить только объекты,
  реализованные в List.
* Вы можете получить индекс элемента, используя Iterator. Но так как List
  является последовательным и основан на индексах, вы можете получить индекс
  элемента, используя ListIterator.  
**Источник.**<https://ru.gadget-info.com/difference-between-iterator>


### 82. Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?
**Ответ.**  
Итератор похож на указатель своими основными операциями: он указывает на отдельный 
элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции 
для перехода к другому элементу списка (следующему или предыдущему). Контейнер, 
который реализует поддержку итераторов, должен предоставлять первый элемент 
списка, а также возможность проверить, перебраны ли все элементы контейнера 
(является ли итератор конечным). Таким образом без курсора просто нельзя будет 
реализовать безошибочное передвижение по коллекции.  
**Источник.**<https://javastudy.ru/interview/collections/>


### 83. Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?
**Ответ.**  
Абстрактный класс EnumSet<E extends Enum<E>> наследуется от абстрактного класса 
AbstractSet. Класс специально реализован для работы с типами enum. Все элементы 
такой коллекции должны принадлежать единственному типу enum, определенному явно 
или неявно. Внутренне множество представимо в виде вектора битов,
обычно единственного long. Множества нумераторов поддерживают перебор
по диапазону из нумераторов. Скорость выполнения операций над таким множеством 
очень высока, даже если в ней участвует большое количество элементов.  
**Источник.**<https://docs.oracle.com/javase/tutorial/collections/implementations/set.html>


### 84. Как происходит удаление элементов из ArrayList?   Как меняется в этом случае размер ArrayList?
**Ответ.**  
Удалять элементы можно двумя способами:
— по индексу remove(index)  
— по значению remove(value)  
С удалением элемента по индексу всё достаточно просто:  
Сначала определяется какое количество элементов надо скопировать;  
затем копируем элементы используя System.arraycopy();  
уменьшаем размер массива и забываем про последний элемент.  
При удалении по значению, в цикле просматриваются все элементы списка, до тех пор
пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.  
При удалении элементов текущая величина capacity не уменьшается, что может 
привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом trimToSize().  
У метода remove() есть две особенности.  
Во-первых, он не оставляет “дыр”. В нем уже реализована логика сдвига элементов 
при удалении элемента из середины.  
Во-вторых, он может удалять объект не только по индексу(как обычный массив), но 
и по ссылке на объект.  
Нельзя проводить одновременно итерацию (перебор) коллекции и изменение ее элементов.  
**Источник.**<https://habr.com/ru/post/128269/>


### 85. Можно ли использовать массив в качестве ключа для HashMap?   Если да, то какие есть особенности.
**Ответ.**
Любой массив не может нормально работать как ключ в HashMap, так 
как массивы не переопределяют equals, поэтому два массива будут считаться равными, 
только если они относятся к тому же объект.  
Вам придется обернуть byte[] в какой-то пользовательский класс, который 
переопределяет hashCode и equals, и использует этот настраиваемый класс в 
качестве ключа к вашему HashMap.  


### 86. Где определены полиморфные алгоритмы для работы с коллекциями?   Опишите основные группы.
**Ответ.**
Класс Collections содержит полиморфные алгоритмы, которые используются при работе с коллекциями.  
Этот класс содержит методы основных алгоритмов Сollection framework, а именно 
методы бинарного поиска, сортировка, перемешивание, а также метод, возвращающий 
обратный порядок элементов и многие другие.  
Алгоритм сортировки переупорядочивает список таким образом, чтобы его элементы 
располагались в возрастающем порядке в соответствии с отношением упорядочения. 
Предусмотрены две формы операции. Простая форма принимает список и сортирует 
его в соответствии с естественным порядком элементов.  
Алгоритм перемешивания делает противоположное тому, что делает sort, уничтожая 
любые следы порядка, которые могли присутствовать в списке. То есть этот алгоритм 
переупорядочивает список на основе входных данных из источника случайности,
так что все возможные перестановки происходят с равной вероятностью, предполагая 
справедливый источник случайности.  

Алгоритм бинарного поиска ищет указанный элемент в отсортированном списке. Этот 
алгоритм имеет две формы. Первый принимает список и элемент для поиска 
(«ключ поиска»). Эта форма предполагает, что список отсортирован в порядке 
возрастания в соответствии с естественным порядком его элементов. Вторая форма 
принимает компаратор в дополнение к списку и ключу поиска и предполагает, что 
список отсортирован в порядке возрастания в соответствии с указанным компаратором. 
Алгоритм сортировки можно использовать для сортировки списка до вызова бинарного поиска.   

Частотный и непересекающийся алгоритмы проверяют некоторые аспекты состава одной или нескольких коллекций:   
 * frequency — подсчитывает количество раз, когда указанный элемент встречается в указанной коллекции;  
 * disjoint - определяет, являются ли две коллекции непересекающимися; то есть, не содержат ли они общих элементов;  

### 87. В чем заключается назначение метода:  
Collections.unmodifiableCollection(Collection<?   extends T> c) 

**Ответ.**  
The unmodifiableCollection() method of java.util.Collections class is used to 
return an unmodifiable view of the specified collection. This method allows modules 
to provide users with “read-only” access to internal collections. Query operations 
on the returned collection “read through” to the specified collection, and attempts 
to modify the returned collection, whether direct or via its iterator, result in 
an UnsupportedOperationException.
The returned collection does not pass the hashCode and equals operations through
to the backing collection, but relies on Object’s equals and hashCode methods. 
This is necessary to preserve the contracts of these operations in the case that 
the backing collection is a set or a list.
The returned collection will be serializable if the specified collection is serializable.  
Syntax:  
```java
public static <T> Collection<T> 
    unmodifiableCollection(Collection<? extends T> c)
```
Parameters: This method takes the collection as a parameter for which an unmodifiable view is to be returned.  
Return Value: This method returns an unmodifiable view of the specified collection.  
```java
// Java program to demonstrate
// unmodifiableCollection() method
// for <Character> Value
  
import java.util.*;
  
public class GFG1 {
    public static void main(String[] argv) throws Exception
    {
        try {
  
            // creating object of ArrayList<Character>
            List<Character> list = new ArrayList<Character>();
  
            // populate the list
            list.add('X');
            list.add('Y');
  
            // printing the list
            System.out.println("Initial list: " + list);
  
            // getting unmodifiable list
            // using unmodifiableCollection() method
            Collection<Character>
                immutablelist = Collections
                                    .unmodifiableCollection(list);
        }
        catch (UnsupportedOperationException e) {
  
            System.out.println("Exception thrown : " + e);
        }
    }
}
```
Output:  
```java
Initial list: [X, Y]
```
**Источник.**<https://www.geeksforgeeks.org/collections-unmodifiablecollection-method-in-java-with-examples/>

### 88. Перечислите различия между массивами и коллекциями?
**Ответ.**  
* массив имеет постоянный размер, коллекция - динамический массив;  
* массив неизменяемый;  
* коллекции не могу содержать примитивных данных;  
* коллекции параметризуются, массивы - нет;  


### 89. Массивы и коллекции являются ковариантными или инвариантными?   Поясните ответ.
**Ответ.**
Массивы отличаются от типичного типа двумя важными способами. Первые массивы 
ковариантны. Дженерики являются инвариантными.  
Ковариант просто означает, что если X является подтипом Y, тогда X [] также
будет подтипом Y []. Массивы являются ковариантными. Поскольку string является подтипом Object.  
Инвариантно просто означает независимо от того, что X является подтипом Y или нет.  
**Источник.**<https://habr.com/ru/post/218753/>


### 90. Дано:
```java
SortedSet<Entity> set = ...;
```
### Найдите в jdk:
#### - тип 1, для которого SortedSet<Entity> является подтипом.
#### - подтип 2 для SortedSet<Entity>.
### Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:
```java
set1 = set;
set = set2;
```
**Ответ.**

**Источник.**<>


### 91. Массивы и коллекции являются reified (овеществленные) или non-reified типами?   Поясните ответ.
**Ответ.**  
Вторым важным отличием массивов от обобщенных типов является то, что
массивы являются типами, доступными при выполнении (reified). Это
значит, что массивы знают тип элементов во время выполнения и обеспечивают
его. Как было сказано ранее, попытавшись сохранить String в массив
Long, вы получите исключение ArrayStoreException. Обобщенные типы,
напротив, реализуются с использованием затирания (erasure). Это значит,
что они обеспечивают ограничения на типы только на этапе компиляции,
а затем отбрасывают (или затирают} информацию о типах элементов при выполнении.
Затирание позволяет обобщенным типам свободно взаимодействовать
со старым кодом, который не использует обобщенные типы,
обеспечивая плавный переход к обобщенным типам в Java 5.
Из-за этих фундаментальных различий массивы и обобщенные типы не
удается “перемешивать”. Например, нельзя создавать массив обобщенного
типа, параметризованного типа или с параметрами типа.  
Почему нельзя создавать обобщенные массивы? Потому что это небезопасно
с точки зрения типов. Если бы это было разрешено, приведение типов,
генерируемое компилятором в остальном корректной программе, могло бы
приводить к исключению времени выполнения ClassCastException. Это
нарушило бы фундаментальные гарантии, предоставляемые системой обобщенных
типов.  
**Источник.** Блох, Джошуа. Java: эффективное программирование, 3-е изд.
