### 1. Что появится в консоли в результате работы фрагмента программы?

```java
String a="java";
        a.toUpperCase();
        System.out.println(a);
```

**Ответ.**  
`java`  
Т.к. класс String помечен как final, то любая манипуляция со строкой приведет к
созданию новой. После создания объекта его состояние изменить нельзя. Операцию
можно выполнить присвоив действие новому объекту: String b = a.toUpperCase();

### 2. Что появится в консоли в результате работы фрагмента программы?

### Поясните ответ.

````java
String s1="Java";
        String s2="Java";
        String s3=new String("Java");
        System.out.println("s1 == s2 : "+(s1==s2));
        System.out.println("s1 == s3 : "+(s1==s3));
        System.out.println(s1.equals(s3));
````

**Ответ.**  
s1 == s2 : true s1 == s3 : false true При создании объекта с помощью класса
String, он помещается в пул литералов. При создании такого же объекта происходит
сравнение с уже помещенным, и поскольку объекты эквивалентны, то две ссылки
ссылаются на один объект, что и происходит при сравнении ссылок при помощи
оператора ==. C помощью оператора new происходит создание нового объекта.
Поэтому при сравнении двух объектов оператором == на консоль выводится false.
Метод equals() производит сравнение двух объектов по-содержимому.

### 3. Можно ли выполнить наследование от класса String? Почему?

**Ответ.**  
Класс String объявлен как final, что означает невозможность создания собственных
порожденных классов со свойствами строки.  
**Источник.** <Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 4. Назовите основные, на ваш взгляд, методы класса String.

**Ответ.**   
String concat(String s) или «+» — слияние строк;  
boolean equals(Object ob) и equalsIgnoreCase(String s) — сравнение строк с
учетом и без учета регистра соответственно;  
int compareTo(String s) и compareToIgnoreCase(String s) — лексикографическое
сравнение строк с учетом и без учета их регистра. Метод осуществляет вычитание
кодов первых различных символов вызывающей и передаваемой строки в метод строк и
возвращает целое значение. Метод возвращает значение нуль в случае, когда
equals() возвращает значение true;  
boolean contentEquals(StringBuffer ob) — сравнение строки и содержимого объекта
типа StringBuffer;  
String substring(int n, int m) — извлечение из строки подстроки длины m-n,
начиная с позиции n. Нумерация символов в строке начинается с нуля;  
String substring(int n) — извлечение из строки подстроки, начиная с позиции n;  
int length() — определение длины строки;  
int indexOf(char ch) — определение позиции символа в строке;  
static String valueOf(значение) — преобразование переменной базового типа к
строке;  
String toUpperCase()/toLowerCase() — преобразование всех символов вызывающей
строки в верхний/нижний регистр;  
String replace(char с1, char с2) — замена в строке всех вхождений первого
символа вторым символом;  
String intern() — заносит строку в «пул» литералов и возвращает ее объектную
ссылку;  
String trim() — удаление всех пробелов в начале и конце строки;  
char charAt(int position) — возвращение символа из указанной позиции
(нумерация с нуля);  
boolean isEmpty() — возвращает true, если длина строки равна 0;  
char[] getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) — извлечение
символов строки в массив символов;  
static String format(String format, Object… args), format(Locale l, String
format, Object… args) — генерирует форматированную строку, полученную с
использованием формата, интернационализации и др.;  
String[] split(String regex), String[] split(String regex, int limit) — поиск
вхождения в строку заданного регулярного выражения (разделителя) и деление
исходной строки в соответствии с этим на массив строк.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 5. Какие разновидности конструкторов использует класс String?

**Ответ.**  
Класс String поддерживает несколько конструкторов, например: String(), String(
String str), String(byte[] asciichar), String(char[] unicodechar), String(
StringBuffer sbuf), String(StringBuilder sbuild) и др. Эти конструкторы
используются для создания объектов класса String на основе инициализации
значениями из массива типа char, byte и др.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 6. Какие классы в стандартной библиотеке Java работают со строками?

**Ответ.**  
Системная библиотека Java содержит классы String, StringBuilder и StringBuffer,
поддерживающие хранение строк, их обработку и определенные в пакете java.lang,
подключаемом к приложению автоматически. Для форматирования и обработки строк
применяются также классы Formatter, Pattern, Matcher, StringJoiner и другие.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 7. Почему экземпляры класса String в Java неизменные и финализированные?

**Ответ.**  
Строка неизменяема в Java из-за безопасности, синхронизации и параллелизма,
кэширования и загрузки классов. Причина создания строки final состоит в том,
чтобы разрушить неизменность и не позволить другим расширять ее. Объекты String
кэшируются в пуле String, и это делает String неизменяемым. К кэшированным
строковым литералам обращаются несколько клиентов. Таким образом, всегда
существует риск, когда действие, выполняемое одним клиентом, влияет на всех
остальных клиентов. Например, если один клиент выполняет действие и меняет
строковое значение с Давление на ДАВЛЕНИЕ, все остальные клиенты также увидят
это значение. По соображениям производительности кэширование объектов String
было важно, поэтому, чтобы устранить этот риск, мы должны сделать String
неизменяемым.  
**
Источник.**<https://www.javatpoint.com/why-string-is-immutable-or-final-in-java#:~:text=The%20String%20is%20immutable%20in,it%20makes%20the%20String%20immutable.>

### 8. Заполните ячейки таблицы (Да/Нет).

**Ответ.**

```xls
Characteristic                 String        StringBuilder        StringBuffer
Неизменяемый (Immutable)?        Да              Нет                  Нет
Имеет пул (Pooled)?              Да              Нет                  Нет
Потокобезопасный (Thread-safe)?  Да              Нет                  Да
Может изменять размер?           Нет             Да                   Да 
```

### 9. В чем разница и что общего между StringBuffer и StringBuilder?

**Ответ.**  
Основным отличием StringBuilder от StringBuffer является потокобезопасность
последнего. Более высокая скорость обработки есть следствие отсутствия
потокобезопасности класса StringBuilder.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

### 10. Когда лучше использовать StringBuffer, а когда StringBuilder?

**Ответ.**  
StringBuilder следует применять, если не существует вероятности использования
объекта в конкурирующих потоках.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 11. Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?

**Ответ.**  
void setLength(int n) — установка размера буфера;  
void ensureCapacity(int minimum) — установка гарантированного минимального
размера буфера;  
int capacity() — возвращение текущего размера буфера;  
StringBuffer append(параметры) — добавление к содержимому объекта  
строкового представления аргумента, который может быть символом, значением
базового типа, массивом и строкой;  
StringBuffer insert(параметры) — вставка символа, объекта или строки в указанную
позицию;  
StringBuffer deleteCharAt(int index) — удаление символа;  
StringBuffer delete(int start, int end) — удаление подстроки;  
StringBuffer reverse() — обращение содержимого объекта.    
**Источник.**Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

### 12. Какие методы сравнения строк имеются в строковых классах?

**Ответ.**  
boolean equals(Object ob) и equalsIgnoreCase(String s) — сравнение строк с
учетом и без учета регистра соответственно;  
int compareTo(String s) и compareToIgnoreCase(String s) — лексикографическое
сравнение строк с учетом и без учета их регистра. Метод осуществляет вычитание
кодов первых различных символов вызывающей и передаваемой строки в метод строк и
возвращает целое значение. Метод возвращает значение нуль в случае, когда
equals() возвращает значение true; boolean contentEquals(StringBuffer ob) —
сравнение строки и содержимого объекта типа StringBuffer;  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 13. Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.

**Ответ.**
```java
public static boolean isPalindrome(String text){
        String newWord=new StringBuilder(text).reverse().toString();
        return newWord.equalsIgnoreCase(text);
        }
```

### 14. Что появится в консоли в результате работы фрагмента программы?
### Поясните ответ.
```java
final String ZA=" за ";
        String value="ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
        String[]monthYear=value.split(ZA)[1].split(" ",3);
        System.out.println(Arrays.toString(monthYear));
```
**Ответ.**  
`[январь, 2019, г.]`
Строка value разбивается выражением " за " на два массива с индексом 0 и 1 т.к.
найдено одно совпадение и сразу же массив с индексом 1 разбивается
выражением " " 3 раза. В итоге получаем массив из трех слов.

### 15. Что появится в консоли в результате работы фрагмента программы?
### Поясните ответ.
```java
String s4="1"+2+3;
        String s5=1+2+"3";
        System.out.println(s4);
        System.out.println(s5);
```
**Ответ.**  
`123`
`33`  
Этот непредсказуемый результат связан с тем, что компилятор оценивает данное
выражение слева направо, учитывая, что операторы имеют одинаковый приоритет. Как
только он встречает строку, он рассматривает остальную часть выражения как
строку (опять же на основе порядка приоритета выражения).  
**Источник.** <https://www.geeksforgeeks.org/addition-and-concatenation-using-plus-operator-in-java/>

### 16. Что появится в консоли в результате работы фрагмента программы?

### Поясните ответ.

````java
String s="abcde ";
        System.out.println(s.trim().length());
        System.out.println(s.charAt(4));
        System.out.println(s.indexOf('e'));
        System.out.println(s.indexOf("de"));
        System.out.println(s.substring(2,4).toUpperCase());
        System.out.println(s.replace('a','1'));
        System.out.println(s.contains("DE"));
        System.out.println(s.startsWith("a"));
````

**Ответ.**

```java
5
        e
        4
        3
        CD
        1 bcde
        false
        true
```  

### 17. Что появится в консоли в результате работы фрагмента программы?
### Поясните ответ.

```java
StringBuilder b=new StringBuilder();
        b.append(12345).append('-');
        System.out.println(b.length());
        System.out.println(b.indexOf("-"));
        System.out.println(b.charAt(2));
        StringBuilder b2=b.reverse();
        System.out.println(b.toString());
        System.out.println(b==b2);
```
**Ответ.**
```java
        6
        5
        3
        -54321
        true
``` 

12345- - добавляем к строке символ "-"; 6 - длина строки составит 6 знаков; 5 -
индекс символа "-"; 3 - число под индексом 2; -54321 - реверс строки.

### 18. Что появится в консоли в результате работы фрагмента программы?
### Поясните ответ.
```java  
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
**Ответ.**
```java
        a-bde
        bd
```
a-bde - вставка символа и удаление символов с соответствующими индексами, не
включая; bd - вывод подстроки с соответствующими индексами, не включая
последний.

### 19. Что появится в консоли в результате работы фрагмента программы?
### Поясните ответ.
```java
StringBuffer sb=new StringBuffer("abcde");
        sb.insert(2,"123");
        System.out.println(sb);
        sb.append("456");
        System.out.println(sb);
        sb.reverse();
        System.out.println(sb);
```
**Ответ.**

```java
ab123cde
        ab123cde456
        654edc321ba
```  

sb.insert(2,"123") - вставляем на позицию с индексом 2 символы 123; sb.append("
456") - вставляет в конец строки символы 456; sb.reverse() - операция позволяет
развернуть выражение в обратном порядке;

### 20. Каким образом можно сцепить строки Java? Назовите не менее 3 способов.

**Ответ.**  
Конкатенация строк оператором + (конкатенация строк):

```java
String hello="Hello";
        String world=" World";
        System.out.println(hello+world);
```

Добавление строк в StringBuilder:

```java
StringBuilder s=new StringBuilder();
        s.append("Hello");
        s.append(" World");
        s.append(" in Java!");
        System.out.println(s.toString());
```

Конкатенация строк методом concat():

```java
   String s1="Sachin ";
        String s2="Tendulkar";
        String s3=s1.concat(s2);
        System.out.println(s3);//Sachin Tendulkar 
```  

Конкатенация строк с использованием метода format():

```java
String s1=new String("Hello");    //String 1  
        String s2=new String(" World");    //String 2  
        String s=String.format("%s%s",s1,s2);   //String 3 to store the result  
        System.out.println(s.toString());  //Displays result  
```  

Объединение строк с использованием метода String.join() (Java Version 8+):

```java
String s1=new String("Hello");    //String 1  
        String s2=new String(" World");    //String 2  
        String s=String.join("",s1,s2);   //String 3 to store the result  
        System.out.println(s.toString());  //Displays result  
```
**Источник.** <https://www.javatpoint.com/string-concatenation-in-java#:~:text=There%20are%20two%20ways%20to,By%20concat()%20method>

### 21. Чем отличаются пустая и нулевая строки?

**Ответ.**  
Язык программирования Java различает нулевые и пустые строки. Пустая строка —
это экземпляр строки нулевой длины, тогда как нулевая строка вообще не имеет
значения. Пустая строка представляется как "". Это последовательность нулевых
символов.  
**Источник.** <https://docs.oracle.com/javaee/7/tutorial/bean-validation002.htm#:~:text=The%20Java%20programming%20language%20distinguishes,character%20sequence%20of%20zero%20characters.>

### 22. В какой кодировке хранятся символы в строке?

**Ответ.**  
Java хранит строки как UTF-16 внутри. "кодировка по умолчанию" не совсем верна.
Java хранит строки как UTF-16 внутри, но кодировка, используемая извне,
«системная кодировка по умолчанию», варьируется от платформы к платформе и даже
может быть изменена такими вещами, как переменные среды на некоторых платформах.
ASCII — это подмножество Latin 1, которое является подмножеством Unicode. UTF-16
— это способ кодирования Unicode. Поэтому, если вы выполните тест int i = 'x'
для любого символа, попадающего в диапазон ASCII, вы получите значение ASCII.
Однако UTF-16 может представлять намного больше символов, чем ASCII.  
**Источник.** <https://stackoverflow.com/questions/4453269/what-is-the-character-encoding-of-string-in-java#:~:text=Java%20stores%20strings%20as%20UTF%2D16%20internally.>

### 23. Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?

**Ответ.**  
Класс String реализует три интерфейса, а именно. Serializable, Comparable и
CharSequence. А классы StringBuffer и StringBuilder реализуют Serializable и
CharSequence.  
**Источник.**<https://www.edureka.co/blog/string-vs-stringbuffer-vs-stringbuilder/>

### 24. Что такое кодовые точки и кодовые единицы?

**Ответ.**  
В документации API Java SE кодовая точка Unicode используется для значений
символов в диапазоне от U+0000 до U+10FFFF, а единица кода Unicode используется
для 16-битных значений char, которые являются кодовыми единицами кодировки
UTF-16.  
**Источник.** <https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#:~:text=In%20the%20Java%20SE%20API,of%20the%20UTF%2D16%20encoding.>

### 25. Объясните назначение метода intern(). Что появится в консоли в результате работы фрагмента программы? Поясните ответ.

```java
class GFG {
    public static void main(String[] args) {
        String s1 = new String("GFG");
        String s2 = s1.intern();
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
        String s3 = "GFG";
        System.out.println(s2 == s3);
    }
}
```
**Ответ.**  
false - оператор == сравнивает ссылки на объект (s1 - объект создан при помощи
оператора new в куче, s2- ссылается на строку в пуле);  
true - метод equals сравнивает содержимое объектов, оно равно; true - в пуле
литералов содержится строка на которую ссылаются s2 и s3;  
Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к
нашему объекту, что подтверждается методом s1.equals(s2), тогда возвращается
ссылка на строку из пула. В противном случае объект строки добавляется в пул и
ссылка на этот объект возвращается.

### 26. Как преобразовать строку в число?

**Ответ.**
```java
Integer x=Integer.valueOf(str);
// or
        int y=Integer.parseInt(str);
```

* valueOf returns a new or cached instance of java.lang.Integer
* parseInt returns primitive int.  
**Источник.** <https://stackoverflow.com/questions/5585779/how-do-i-convert-a-string-to-an-int-in-java>

### 27. Какой метод вызывается для преобразования переменной в строку?

**Ответ.**  
Метод String.valueOf() преобразует int в String. valueOf() — это статический
метод класса String. Сигнатура метода valueOf() приведена ниже:  
public static String valueOf(int i);

Метод Integer.toString() преобразует int в String. toString() — это статический
метод класса Integer. Сигнатура метода toString() приведена ниже:  
public static String toString(int i);

Метод String.format() используется для форматирования заданных аргументов в
строку. Он представлен начиная с Jdk 1.5.:  
public static String format(String format, Object... args);  
**Источник.** <https://www.javatpoint.com/java-int-to-string>

### 28. Каким методом в классе String можно проверить строку на соответствие регулярному выражению?

**Ответ.**  
boolean matches(String regex): проверяет, соответствует ли эта строка указанному
регулярному выражению.  
**Источник.** <https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html>

### 29. Создайте класс с полями: int, long, float и double, String. Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.

**Ответ.**
```java
public class Fields {
    private int a = 1;
    private long b = 10000;
    private float c = 579.333365F;
    private double d = 82.15;
    private String str = "JAVA";

    @Override
    public String toString() {
        return String.format("%d;%d;%.5f;%.3f;%s", a, b, c, d, str);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Fields fields = new Fields();
        System.out.println(fields.toString());
    }
}
```

1;10000;579,33337;82,150;JAVA

### 30. Опишите: - назначение класса Formatter, - методы format(), - спецификаторы формата.

**Ответ.**  
Для создания форматированного текстового вывода предназначен класс
java.util.Formatter. Этот класс обеспечивает преобразование формата,
позволяющее выводить числа, строки, время и даты в любом необходимом
разработчику виде. В классе Formatter объявлен метод format(), который
преобразует переданные в него параметры в строку заданного формата и сохраняет в
объекте типа Formatter. Formatter format(Locale loc, String fmtString,
Object…args) - форматирует аргументы, переданные в аргументе переменной длины
args, в соответствии со спецификаторами формата, содержащимися в fmtString. При
форматировании используются региональные установки, заданные в lос. Возвращает
вызывающий объект.  
format(String fmtString, Object…args) - перегруженная версия метода без
использования локализации.

Спецификаторы формата:
* %a - Шестнадцатеричное значение с плавающей точкой
* %b - Логическое (булево) значение аргумента
* %c - Символьное представление аргумента
* %d - Десятичное целое значение аргумента
* %h - Хэш-код аргумента
* %e - Экспоненциальное представление аргумента
* %f - Десятичное значение с плавающей точкой
* %g - Выбирает более короткое представление из двух: %е или %f
* %o - Восьмеричное целое значение аргумента
* %n - Вставка символа новой строки
* %s - Строковое представление аргумента
* %t - Время и дата
* %x - Шестнадцатеричное целое значение аргумента
* %% - Вставка знака %  
**Источник.** <Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.>

### 31. Что представляет собой регулярное выражение?

### На каких классах базируются regex-возможности языка Java?

### В каком пакете эти классы расположены?

**Ответ.**  
Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте. В Java
исходным представлением этого шаблона всегда является строка, то есть объект
класса String. Однако не любая строка может быть скомпилирована в регулярное
выражение, а только та, которая соответствует правилам написания регулярного
выражения – синтаксису, определенному в спецификации языка. Для написания
регулярного выражения используются буквенные и цифровые символы, а также
метасимволы – символы, имеющие специальное значение в синтаксисе регулярных
выражений.  
Класс java.util.regex.Pattern применяется для определения регулярных выражений (
шаблонов). О каждом соответствии можно получить информацию с помощью класса
java.util.regex.Matcher. Находятся в пакете java.util.regex.  
**Источник.**<https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java>

### 32. Опишите назначение классов Pattern и Matcher.

### Каким образом они связываются?

### Предоставить простейший код их взаимодействия.

**Ответ.**  
Класс java.util.regex.Pattern применяется для определения регулярных выражений (
шаблонов), для которых ищется соответствие в строке, файле или другом объекте,
представляющем последовательность символов. Для определения шаблона применяются
специальные синтаксические конструкции. О каждом соответствии можно получить
информацию с помощью класса java.util.regex.Matcher.  
```java
public static void main(String[] args) {
    String text = "Егор Алла Александр";
    Pattern pattern = Pattern.compile("А.+а");
    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        System.out.println(text.substring(matcher.start(), matcher.end())); // Алла Алекса
    }
}
```
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 33. При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.

**Ответ.**

### 34. Какой из способов сравнения строк предпочтительнее? Поясните ответ.
str.equals("abc"); или "abc".equals(str);

**Ответ.**  
"abc".equals(str); предпочтительнее т.к. мы никогда не получим исключение 
NullPointerException, потому что литерал не может быть нулевым.

### 35. Как сравнить объекты StringBuilder и StringBuffer?

**Ответ.**  
Для классов StringBuffer и StringBuilder не переопределены методы equals()
и hashCode(), т. е. сравнить содержимое двух объектов невозможно, следовательно 
хэш-коды всех объектов этого типа вычисляются так же, как и для класса Object. 
При идентичном содержимом у двух экземпляров, размеры буфера каждого могут 
отличаться, поэтому сравнение на эквивалентность объектов представляется неоднозначным.    
**Источник.** <Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.>

### 36. Что появится в консоли в результате работы фрагмента программы? Поясните ответ.
```java
System.out.printf("%d студентов пришли сдавать зачет по %8.10s, \n"
        +"из них не сдали %d, %s",10,"J2SE",5,"а остальные сдали на отлично");
```
**Ответ.**  
10 студентов пришли сдавать зачет по     J2SE, из них не сдали 5, а остальные сдали на отлично

System.out.printf служит для вывода форматированной строки на консоль.
%8.10s - ширина поля ввода и количество вводимых символов т.е. 10s
%d - вывод числа;
%s - вывод символов;

### 37. Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".

**Ответ.**
"https?://(\\w+\\.)[by]"

### 38. Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.

#### Например, запрос `https://bsut.by?value1=5&value2=10&iscan=true`.
Вывод:
`value1=5`
`value2=10`
`iscan=true`

**Ответ.**
```java
	public static void main(String[] args) {
        String s = "https://bsut.by?value1=5&value2=10&iscan=true";
        String reg = "\\w+=\\w+";
        Pattern p = Pattern.compile(reg);
        Matcher m = pattern.matcher(s);
        while (m.find()) {
        System.out.println(m.group());
        }
    }
```

### 39. Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.

**Ответ.**  
предопределенные классы символов:  
```xml
[abc] a, b или c
[^abc] символ, исключая a, b и c
[a-z] символ между a и z
[a-d[m-p]] между a и d, или между m и p
```
предопределенные классы символов:  
```xml
. любой символ
\d или \p{Digit} [0-9]
\D [^0-9]
\s или \p{Space} [ \t\n\x0B\f\r]
\S [^\s]
\w [0-9_A-Za-z]
\W [^\w]
\p{Lower} [a-z]
\p{Upper} [A-Z]
\p{Punkt} !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\p{Blank} Пробел или табуляция
```
При создании регулярного выражения могут использоваться логические операции:  
```xml
ab после a следует b
a|b a либо b
(a) а
```
квантификаторы:  
```xml
символ   описание 
a?       a один раз или ни разу
a*       a ноль или более раз
a+       a один или более раз
a{n}     a n раз
a{n,}    a n или более раз
a{n,m}   a от n до m
```
Существует еще два типа квантификаторов, которые образованы прибавлением суффикса 
«?» (слабое или неполное совпадение) или «+» («жадное» или собственное
совпадение) к вышеперечисленным квантификаторам. Неполное
совпадение соответствует выбору с наименее возможным количеством символов, а 
собственное — с максимально возможным.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 40. Назовите основные, на ваш взгляд, методы класса Pattern.

**Ответ.**  
Pattern compile(String regex) — возвращает Pattern, который соответству-
ет regex;
boolean matches(String regex, CharSequence input) — проверяет на соот-
ветствие строки input шаблону regex;
String[] split(CharSequence input) — разбивает строку input, учитывая, что
разделителем является шаблон;
Matcher matcher(CharSequence input) — возвращает Matcher, с помощью
которого можно находить соответствия в строке input.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.

### 41. Назовите основные, на ваш взгляд, методы класса Matcher.

**Ответ.**
boolean matches() — проверяет, соответствует ли вся информация шаблону;  
boolean lookingAt() — поиск последовательности символов, начинающейся
с начала строки и соответствующей шаблону;  
boolean find() или boolean find(int start) — ищет последовательность символов, 
соответствующих шаблону, в любом месте строки. Параметр start указывает на 
начальную позицию поиска.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С.Романчик.
