### 1. Что такое исключения?
**Ответ.**  
Исключение в языке Java — это ОБЪЕКТ, который описывает исключительную
(т. е. ошибочную) ситуацию, произошедшую в некоторой части кода.
Другими словами, исключение — это ошибка времени выполнения.    
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 2. Какие действия производит система времени выполнения при возникновении исключения?
**Ответ.**  
Когда исключительная ситуация возникает, создается объект, представляющий это
исключение, и «вбрасывается» в метод, вызвавший ошибку.
В свою очередь, метод может выбрать, обрабатывать ли исключение самому или
передать его куда-то еще.
В любом случае, в некоторой точке исключение «захватывается» и
обрабатывается.
Исключения могут генерироваться исполнительной системой Java, или ваш код
может сгенерировать их "вручную".
Выбрасываемые исключения касаются фундаментальных ошибок, которые
нарушают ограничения среды выполнения или правила языка Java.
Исключения, сгенерированные вручную, обычно используются, чтобы
сообщить вызывающей программе о некоторой аварийной ситуации.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 3. Как называется блок кода, который обрабатывает исключение?
**Ответ.**  
Система выполнения ищет в стеке вызовов метод, содержащий блок кода, способный обработать исключение. 
Этот блок кода называется обработчиком исключений.  
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html>

### 4. Как реализуется требование «Поймай или Укажи» (Catch or Specify)?
**Ответ.**  
Действительный код языка программирования Java должен соответствовать требованию 
Catch or Specify. Это означает, что код, который может генерировать определенные исключения, должен быть заключен в один из следующих элементов:  
* Оператор try, который перехватывает исключение. Попытка должна предоставить обработчик исключения;  
* Метод, указывающий, что он может генерировать исключение. Метод должен предоставить предложение throws, в котором перечислены исключения;  
* Код, который не соответствует требованию Catch или Specify, не будет компилироваться.  
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html>

### 5. Какая иерархия классов исключений?
**Ответ.**  
Все исключения являются наследниками суперкласса Throwable и его подклассов Error и Exception из пакета java.lang.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.  

### 6. Какие виды исключений относятся к непроверяемым?
**Ответ.**  
Исключительные ситуации типа RuntimeException - непроверяемые (unchecked) исключения.
Исключения типа RuntimeException автоматически генерируются при
возникновении ошибок во время выполнения приложения.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 7. Какие компоненты могут входить в обработчик исключений?
**Ответ.**  
Обработка исключений в Java управляется с помощью пяти ключевых слов:
* try,  
* catch,  
* throw,  
* throws,  
* finally.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 8. Для каких ситуаций используется оператор try-with-resources?
**Ответ.**  
В Java 7 реализована возможность автоматического закрытия ресурсов в
блоке try с ресурсами (try-with-resources).
В операторе try открывается ресурс (файловый поток ввода), который
затем читается.
При завершении блока try данный ресурс автоматически закрывается, поэтому нет
никакой необходимости явно вызывать метод close() у потока ввода, как это было в
предыдущих версиях Java.
Автоматическое управление ресурсами возможно только для тех ресурсов,
которые реализуют интерфейс java.lang.AutoCloseable.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 9. Какой код заключается в блок try?
**Ответ.**  
Блок try Java используется для включения кода, который может вызвать исключение. 
Он должен использоваться внутри метода. Если в конкретном операторе в блоке try 
возникает исключение, остальная часть кода блока выполняться не будет. Поэтому 
рекомендуется не хранить в блоке try код, который не вызовет исключения.  
**Источник.** <https://www.javatpoint.com/try-catch-block#:~:text=Java%20try%20block%20is%20used,will%20not%20throw%20an%20exception.>

### 10. Выполняется ли весь код блока try в случае возникновения исключения?
**Ответ.**  
Если в конкретном операторе в блоке try возникает исключение, остальная часть кода блока выполняться не будет.  
**Источник.** <https://www.javatpoint.com/try-catch-block#:~:text=Java%20try%20block%20is%20used,will%20not%20throw%20an%20exception.>

### 11. Может ли использоваться только один блок try (без catch или finally)?
**Ответ.**  
try может быть в паре с finally, без catch. Работает это точно так же - после выхода 
из блока try выполняется блок finally. Это может быть полезно, например, в следующей ситуации. 
При выходе из метода вам надо произвести какое-либо действие.  
Блок try, без catch и finally это так называемый try with resources. В этом блоке 
выполняется код в котором нужны потоки чтения, записи и т.д. И использование try 
with resources позволяет не закрывать принудительно эти потоки методом close().  
**Источник.** <https://javarush.ru/help/78353>  

### 12. Какое назначение блока catch?  
**Ответ.**  
catch – определяет блок кода, в котором происходит обработка исключения.  
**Источник.** <https://javarush.ru/groups/posts/isklyucheniya-java>

### 13. Сколько блоков catch может содержаться после try-оператора?
**Ответ.**  
В некоторых случаях один фрагмент кода может инициировать более одного исключения. 
Используется два или более операторов catch, каждый для перехвата своего типа исключений.  
Когда используются множественные операторы catch, важно помнить, что подклассы исключений 
должны следовать перед любыми их суперклассами.  
Multi-catch блок может содержать только исключения не входящие в одну иерархию.  
**Источник.** <https://www.examclouds.com/ru/java/java-core-russian/keyword-catch#header2>

### 14. Если применяется несколько блоков catch, то в каком порядке в случае возникновения исключения они вызываются?
**Ответ.**  
Подклассы исключений в блоках catch должны следовать перед любым 
из их суперклассов, иначе суперкласс будет перехватывать эти исключения.  
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик.

### 15. Какой код может быть между блоками try и catch?
**Ответ.**  
Блок try не может существовать при отсутствии выражения catch либо выражения finally. 
Существование какого-либо кода в промежутке между блоками try, catch, finally является невозможным.  
**Источник.** <http://proglang.su/java/exceptions>

### 16. Может ли использоваться блок catch без блока try?
**Ответ.**  
Блок try не может существовать при отсутствии выражения catch либо выражения finally.  
**Источник.** <http://proglang.su/java/exceptions>

### 17. Сколько типов исключений может обрабатывать один блок catch?
**Ответ.**  
В Java 7 стало возможным использовать один обработчик для перехвата сразу
нескольких исключений (multi-catch).
Для одновременной обработки сразу нескольких исключений типы исключений в
блоке catch разделяются оператором ИЛИ (OR).  
**Источник.** <https://javadevblog.com/neskol-ko-blokov-catch-v-odnom-i-povtornoe-vy-brasy-vanie-isklyuchenij-v-java-7.html>

### 18. В случае отсутствия исключения в блоке try выполняется ли блок catch?
**Ответ.**  
Если блок try не вызывает никаких исключений, то блок finally будет выполнен после 
блока try. Если в блоке try есть исключение, то управление сначала передается блоку 
catch, а затем блоку finally.  
**Источник.** <https://www.softwaretestinghelp.com/try-catch-finally-and-throw-in-java/#:~:text=If%20the%20try%20block%20does,and%20then%20the%20finally%20block.>

### 19. Для чего используется блок finally?
**Ответ.**  
Когда исключение выбрасывается, выполнение метода имеет довольно неровный, нелинейный путь,
который изменяет нормальное прохождение потока через метод.
В зависимости от того, как кодирован метод, исключение может вызвать даже
преждевременный выход из него.
Например, если метод открывает файл для ввода и закрывает его для вывода, то
вы вряд ли захотите, чтобы закрывающий файл код был обойден механизмом обработки
исключений.
Для реализации этой возможности и предназначено ключевое слово finally.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 20. В случае отсутствия исключения в блоке try выполняется ли блок finally (при его наличии)?
**Ответ.**  
Если блок try не вызывает никаких исключений, то блок finally будет выполнен после
блока try. Если в блоке try есть исключение, то управление сначала передается блоку
catch, а затем блоку finally.  
**Источник.** <https://www.softwaretestinghelp.com/try-catch-finally-and-throw-in-java/#:~:text=If%20the%20try%20block%20does,and%20then%20the%20finally%20block.>

### 21. Могут ли использоваться блоки try-finally без блока catch?
**Ответ.**  
Да. Блок `Try` может быть в паре с `finally`, без `catch`. Работает это точно так же – после
выхода из блока `try` выполняется блок `finally`. Это может быть полезно, например, в
следующей ситуации. При выходе из метода вам надо произвести какое-либо действие.
А `return` в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым
`return` нецелесообразно. Гораздо проще и эффективнее поместить основной код в `try`,
а код, выполняемый при выходе – в `finally`.
**Источник.** <http://www.skipy.ru/technics/exceptions.html>

### 22. Приведите пример кода, в котором используется оператор try-with-resources.
**Ответ.**  
```java
public class TryWithResources {
    public static void main(String[] args) {
        String filePath = args[0];
        try (FileInputStream in = new FileInputStream(filePath)) {
            int data = 0;
            while ((data = in.read()) != -1) {
                System.out.print("Data: " + data);
            }
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```

### 23. Какой оператор может использоваться вместо try-with-resources?
**Ответ.**  
По возможности следует использовать try-with-resources вместо обычного 
try-catch-finally. Легко забыть закрыть один из ваших ресурсов после нескольких 
часов написания кода или забыть закрыть ресурс, который вы только что добавили 
в свою программу, после случайного всплеска вдохновения.  
**Источник.** <https://rukovodstvo.net/posts/id_1114/>

### 24. Может ли применяться оператор try-with-resources совместно с блоком finally?
**Ответ.**  
Оператора try -with-resources можно дописывать блоки catch и finally . А можно и 
не добавлять, если в них нет необходимости.  
**Источник.** <https://javarush.ru/quests/lectures/questsyntaxpro.level15.lecture00>

### 25. Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?
**Ответ.**  
Программа может сама явно выбрасывать исключения, используя оператор throw.  
Предложение throws перечисляет типы исключений, которые метод может
выбрасывать. Это необходимо для всех исключений, кроме исключений типа Error,
RuntimeException или любых их подклассов.  
Если данное условие не соблюдено, то произойдет ошибка времени компиляции.  
```java
type method-name(parameter-list)
throws exception-list {
// тело метода
}
```  
Здесь exception-list — список разделенных запятыми исключений, которые метод
может выбрасывать.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 26. Сколько исключений может выбрасывать метод?
**Ответ.**  
Метод может генерировать только одно исключение за раз. Метод Java должен объявлять 
любой тип исключения, который он может генерировать. Существуют непроверяемые 
исключения системного уровня, такие как подклассы RuntimeException, которые не 
нужно объявлять.  
**Источник.** <https://www.quora.com/Can-a-method-throw-multiple-exceptions>

### 27. Какое ключевое слово используется для гарантированного выбрасывания исключения?
**Ответ.**  
Если метод способен к порождению исключения, которое он не обрабатывает, он
должен определить свое поведение так, чтобы вызывающие методы могли сами
предохранять себя от данного исключения.
Это обеспечивается включением предложения throws в заголовок объявления
метода.
Предложение throws перечисляет типы исключений, которые метод может
выбрасывать. Это необходимо для всех исключений, кроме исключений типа Error,
RuntimeException или любых их подклассов.
Все другие исключения (кроме исключения типа Error, RuntimeException),
которые метод может выбрасывать, должны быть объявлены в предложении throws.
Если данное условие не соблюдено, то произойдет ошибка времени компиляции.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 28 Можно ли создавать свои собственные классы исключений?
**Ответ.**  
Чтобы создать собственное исключение, его класс надо унаследовать от
Throwable или от его подкласса (чаще всего от класса Exception).
Класс Exception не определяет никаких собственных методов, а наследует эти
методы от класса Throwable. Таким образом, всем исключениям, даже тем, что вы
создаете сами, доступны методы Throwable.  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 29. Приведите примеры наиболее известных подклассов класса Exception.
**Ответ.**  
* ClassNotFoundException: Класс не найден;  
* CloneNotSupportedException: Попытка клонировать объект, который не реализует интерфейс Cloneable;  
* IllegalAccessException: Доступ к классу отклонен;  
* InstantiationException: Попытка создавать объект абстрактного класса или интерфейса;  
* InterruptedException: Один поток был прерван другим потоком;  
* NoSuchFieldException: Требуемое поле не существует;  
* NoSuchMethodException: Требуемый метод не существует;   
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.  

### 30. Приведите примеры наиболее известных подклассов класса RuntimeException.
**Ответ.**  
* ArithmeticException: Арифметическая ошибка типа деления на нуль;  
* ArrayIndexOutOfBoundsException: Индекс массива находится вне границ;  
* ArrayStoreException: Назначение элементу массива несовместимого типа;  
* ClassCastException: Недопустимое приведение типов;  
* IllegalArgumentException: При вызове метода использован незаконный аргумент;  
* IllegalMonitorStateException: Незаконная операция монитора, типа ожидания на разблокированном потоке;  
* IllegalStateException: Среда или приложение находятся в некорректном состоянии;  
* IllegalThreadStateException: Требуемая операция не совместима с текущим состоянием потока;  
* IndexOutOfBoundsException: Некоторый тип индекса находится вне границ;  
* NegativeArraySizeException: Массив создавался с отрицательным размером;  
* NullPointerException: Недопустимое использование нулевой ссылки;  
* NumberFormatException: Недопустимое преобразование строки в числовой формат;  
* SecurityException: Попытка нарушить защиту;  
* StringIndexOutOfBoundsException: Попытка индексировать вне границ строки;  
* UnsupportedOperationException: Встретилась неподдерживаемая операция;  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 31. Что такое сцепление исключений?
**Ответ.**  
Приложение часто реагирует на исключение, вызывая другое исключение. По сути, первое 
исключение вызывает второе исключение. Очень полезно знать, когда одно исключение 
вызывает другое. Цепочки исключений помогают программисту сделать это. Ниже приведены 
методы и конструкторы в Throwable, которые поддерживают связанные исключения.  
* Throwable getCause()  
* Throwable initCause(Throwable)  
* Throwable(String, Throwable)  
* Throwable(Throwable)  
Аргумент Throwable для initCause и конструкторов Throwable — это исключение, 
вызвавшее текущее исключение. getCause возвращает исключение, вызвавшее текущее 
исключение, а initCause устанавливает причину текущего исключения.  
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html>

### 32. Приведите пример кода со сцеплением исключений.
**Ответ.**
```java
try {
    
        } catch (IOException e) {
        throw new SampleException("Other IOException", e);
        }
```
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html>

### 33. Какая информация приводится при трассировке стека во время исключения?  
**Ответ.**  
Трассировка стека – это список методов, которые были вызваны до момента, когда в
приложении произошло исключение.  
**Источник.** <https://ru.stackoverflow.com/questions/510755/>

### 34. В каких случаях целесообразно создавать собственный класс исключения?
**Ответ.**  
* Наличие нескольких классов исключений позволяет программисту быть конкретным в 
своих предложениях catch и перехватывать только те исключения, которые ему 
интересны и знают, что с ними делать.  
* Класс исключений может содержать информацию об ошибке, вызвавшей исключение. 
Например, ArrayIndexOutOfBoundsException содержит индекс массива, вызывающий 
нарушение, а исключения SQL, как правило, содержат коды ошибок и сообщения, 
характерные для базы данных.  
* Спецификации исключений, в которых перечислены классы исключений, можно 
использовать для проверки корректности во время компиляции.

### 35. Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?
**Ответ.**  
Чтобы создать собственное исключение, его класс надо унаследовать от
Throwable или от его подкласса (чаще всего от класса Exception).  
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 36. Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?
**Ответ.**  
* Checked Exceptions следует использовать для предсказуемых, но непредотвратимых ошибок, которые разумно исправить.  
* Unchecked Exceptions следует использовать для всего остального.  
**Источник.** <https://stackoverflow.com/questions/27578/>

### 37. Какие преимущества в механизме выбрасывания и обработки исключений?
**Ответ.**  
Преимущество 1: отделение кода обработки ошибок от «обычного» кода:  
Исключения позволяют отделить детали того, что делать, когда происходит что-то 
необычное, от основной логики программы. В традиционном программировании обнаружение 
ошибок, отчеты и обработка часто приводят к запутанному спагетти-коду. Например, 
рассмотрим здесь метод псевдокода, который считывает весь файл в память.  
Преимущество 2: Распространение ошибок вверх по стеку вызовов:  
Второе преимущество исключений — возможность распространять сообщения об ошибках 
вверх по стеку вызовов методов. Предположим, что метод readFile является четвертым 
методом в серии вызовов вложенных методов, сделанных основной программой: метод1 
вызывает метод2, который вызывает метод3, который, наконец, вызывает readFile.  
Преимущество 3: группировка и дифференциация типов ошибок:  
Поскольку все исключения, создаваемые в программе, являются объектами, группировка 
или категоризация исключений является естественным результатом иерархии классов. 
Примером группы связанных классов исключений на платформе Java являются классы, 
определенные в java.io — IOException и его потомки. IOException является наиболее 
общим и представляет любой тип ошибки, который может возникнуть при выполнении ввода-вывода. 
Его потомки представляют собой более конкретные ошибки. Например, FileNotFoundException 
означает, что файл не может быть расположен на диске.  
**Источник.** <https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html#:~:text=A%20method%20can%20duck%20any,to%20worry%20about%20detecting%20errors.>

### 38. Можно ли выбрасывать исключения в конструкторах?
**Ответ.**  
Да, конструкторам разрешено генерировать исключение в Java. Конструктор — это 
особый тип метода, который используется для инициализации объекта и используется
для создания объекта класса с использованием нового ключевого слова, где объект 
также известен как экземпляр класса.  
**Источник.** <https://www.tutorialspoint.com/can-a-constructor-throw-an-exception-in-java>

### 39. Может ли произойти потеря исключения? Если да – приведите пример.
**Ответ.**  
Блок finally может вызвать потерю исключений.
```java
public class ExceptionLossTest{

    public static void main(String[] args){
        try {
            try {
                throw new Exception("a");
            } finally {
                if (true) {
                    throw new IOException("b");
                }
                System.err.println("c");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("d");
            System.err.println(ex.getMessage());
        }
    }
}
```
Блок finally может вызвать потерю исключений.  
Между тем – результатом его выполнения будет вывод в консоль b. И только. После 
инициации первого исключения – new Exception("a") – будет выполнен блок finally, 
в котором будет брошено исключение new IOException("b"). И именно это исключение 
будет поймано и обработано. Исходное же исключение теряется.  
**Источник.** <http://www.skipy.ru/technics/exceptions.html>

### 40. Обладают ли исключения свойством транзакционности?
**Ответ.**  
Cвойством транзакционности исключения не обладают – действия, произведенные в 
блоке try до возникновения исключения, не отменяются поcле его возникновения.  
**Источник.** <http://www.skipy.ru/technics/exceptions.html>

### 41. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
void methodCatchesSomeException() {
        	...
        	try {
                    	...
        	} catch (SomeException ex) {
                    	...
        	}
        	...
}
```
**Ответ.**  
Является т.к. после перехвата исключения в методе выполняются действия, которые могут
привести к генерации другого исключения, которое уже не будет обработано.  

### 42. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
void methodThrowsSomeCheckedException() {
        	...
        	throw new SomeCheckedException();
        	...
}
```
**Ответ.**  
Является. Checked exceptions — исключения, которые должны быть описаны в throws 
части метода.  

### 43. Является ли данный код верным? Укажите почему.  
```java
void methodThrowsSomeCheckedException() throws SomeCheckedException {
        	...
        	throw new SomeCheckedException();
        	...
}
```
**Ответ.**  
Данный пример верный. Checked exceptions — исключения, которые должны быть 
описаны в throws части метода.  Checked exceptions наследуются от класса Exception 
и предполагаются «бросающимися в глаза» исключениями. Checked exception означает 
ожидаемую проблему, которая может возникнуть в процессе нормальной работы системы.  

### 44. Приведите примеры кода с выбросом RuntimeException явным образом и в случае программной ошибки.  
**Ответ.**  
```java
	public static void main(String[] args) {
        try {
        System.out.println("Внутри try");
        throw new RuntimeException("demo");
        } finally {
        System.out.println("finally для для main ");
        }
        }
``` 
```java
public class DivisionWithTry {
public static void main(String[] args) {
int d, a;
try {
d = 0;
a = 42 / d;
System.out.println("Этот текст никогда не будет напечатан.");
} catch (ArithmeticException e) {
System.out.println("Деление на ноль.");
}
System.out.println("Уже после блока try-catch.");
}
}
```
      
### 45. Можно ли отрефакторить данный код? Если да, то выполните.  
```java
void methodThrowsSomeRuntimeException() {
        	...
        	throw new SomeRuntimeException();
        	...
}
```
**Ответ.**  
```java
void methodThrowsSomeRuntimeException() {
        ...
    try{
        ...
        }catch(SomeRuntimeException e){
        System.err.print("Обработка uncheсked-исключения вне метода:" + e);
        }
}
```

### 46. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
        	...
        	throw new SomeRuntimeException();
        	...
}
```
**Ответ.**  
Является. RuntimeException (unchecked) и используемых для отображения программных ошибок, 
при выполнении приложения throws в объявлении может отсутствовать, так как играет только информационную роль.
Не следует в общем случае в секцию throws помещать unchecked-исключения.
Также обработка unchecked-исключения должна происходить в catch-блоке иначе генерация нового исключения приведет к остановке программы.

### 47. В какой версии Java появился оператор try-with-resources? Приведите пример кода с использованием указанного оператора.  
**Ответ.**  
В Java 7 реализована возможность автоматического закрытия ресурсов в
блоке try с ресурсами (try-with-resources).
```java
public class TryWithResources {
public static void main(String[] args) {
String filePath = args[0];
try (FileInputStream in = new FileInputStream(filePath)) {
int data = 0;
while ((data = in.read()) != -1) {
System.out.print("Data: " + data);
}
} catch (IOException e) {
System.out.println("Error: " + e.getMessage());
}
}
}
```
**Источник.** Java Web Development. Конспект тренинга. Ольга Смолякова. EPAM Systems, 2015.

### 48. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
void methodWithAutocloseableInstance() {
        	...
        	try(SomeResource res = new SomeResource(...)) {
                    	...
        	}
        	...
}
```
**Ответ.**  
Является, т.к. нет блока catch для обработки исключения, которое генерирует блок try.  

### 49. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
void methodWithAutocloseableInstance() {
        	...
        	try(SomeResource res = new SomeResource(...)) {
                    	...
        	} catch (CorrectCheckedException ex) {
                    	…
        	}
        	...
}
```
**Ответ.**  
Не является, т.к. ресурс реализует интерфейс java.lang.AutoCloseable.  

### 50. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
try {
           …
}  catch (SomeException е) {
        	//no code
}
```
**Ответ.**  
Является, т.к. не стоит оставлять пустыми блоки catch. При генерации и перехвате исключения
никто не узнает, что исключительная ситуация имела место, и не станет устранять ее причины.  

### 51. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java 
try {
        	…
}  catch (SomeException е) {
    		System.out.println(“Something went wrong!”);
}
```
**Ответ.**  
Не является. Блок catch обрабатывает исключение и сообщает об исключительной ситуации.  

### 52. Является ли данный код антипаттерном, если блок catch находится не в конце раннер-метода main()? Обоснуйте ответ.  
```java
try {
    		…
}  catch (Exception е) {
    		…
}
…
```
или другой вариант
```java
try {
        	…
}  catch (Throwable е) {
        	…
}
…
```
**Ответ.**  
Антипаттерном будет являться первый вариант:
```java
try {
        ...
/* суперкласс Exception перехватит объекты всех своих подклассов */
catch (Exception e) {
        ...
}
        ...
```

### 53. Является ли данный код антипаттерном? Обоснуйте ответ.  
```java
try {
    	int i = 0;
  	  while(true) {
        	а[i++].f();
        }
} catch(ArraylndexOutOfBoundsException е) {
    	…
}
```
**Ответ.**  
Является. Данный код эквивалентен:
````java
for(int i = 0; i < a.length; i ++){
    a[i].f();
        }
````
Когда производится попытка обращения к первому элементу за пределами массива, бесконечный цикл завершается инициированием
исключительной ситуации ArraylndexOutOfBoundException (Неправильное использование исключения), ее перехватом и последующим игнорированием.  
Идиома цикла, использующая исключения, снижает производительность и делает непонятным программный код.  
исключения, как и подразумевает их название, должны применяться лишь для исключительных ситуаций, 
при обычной обработке использовать их не следует никогда.

### 54. Есть ли недостатки у API написанного только с использованием обрабатываемых исключений?
**Ответ.**  
Использование исключений для обработки ошибок имеет два недостатка. 
Во-первых, исключения могут перехватывать только ошибки времени выполнения. 
Следовательно, программа PL/SQL не может перехватывать и восстанавливать ошибки 
времени компиляции (синтаксические и семантические), такие как таблица или представление не существует.
Во-вторых, исключения могут маскировать оператор, вызвавший ошибку.  
**Источник.** <https://docs.oracle.com/cd/A57673_01/DOC/server/doc/PLS23/ch6.htm#toc053>

### 55. Даны два варианта сеттера. Какой является более предпочтительным в использовании? Обоснуйте ответ.  
### Вариант 1.
```java
void setPositiveValue(int value) {
        	if(value <= 0) {
                    	throw new IllegalArgumentException(...);
        	}
        	this.value = value;
}
```
### Вариант 2.
```java
void setPositiveValue(int value) throws SomeCheckedException {
        	if(value <= 0) {
                    	throw new SomeCheckedException(...);
        	}
        	this.value = value;
}
```
**Ответ.**  
Первый вариант предпочтительнее, т.к. при негативном сценарии второй вариант маскирует проблему.

### 56. Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.
**Ответ.**  
* NullPointerException: исключение NullPointerException возникает, когда программа Java пытается обработать объект, содержащий нулевое значение.  
* ArrayIndexOutOfBoundsException: исключение ArrayIndexOutOfBoundsException возникает при обработке массива и запросе позиции, которая не существует в пределах размера массива.  
* IllegalStateException: исключение IllegalStateException возникает, когда метод вызывается в недопустимое или неподходящее время. Обычно это исключение возникает при попытке удалить элемент из списка во время обработки этого списка.  
* ClassCastException: исключение ClassCastException возникает, когда вы пытаетесь привести один объект к другому объекту, который не является членом иерархии классов.  
* ArithmeticException: ArithmeticException возникает, когда возникает исключительное арифметическое условие. Например, этот тип исключения часто возникает, когда программа пытается разделить на ноль.  
* IllegalArgumentException: исключение IllegalArgumentException часто используется для перехвата ошибок, когда предоставленное значение метода не соответствует ожиданиям.  
**Источник.** <https://rollbar.com/blog/most-common-java-exceptions/>  

### 57. Если недостаточно информации для принятия решения и...  
### 1)исключительная ситуация должна быть исправлена на ближайшем уровне;  
### 2)исключительная ситуация маловероятна  
### Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  
**Ответ.**  
1) экземпляр класса checked исключения;  
2) экземпляр класса unchecked исключения;

### 58. Выделите в блоке try-catch основной и альтернативный сценарии. Обоснуйте ответ.  
```java
try {
        	...
        	User user = source.getUser(login, password);
        	if(GUEST_USER.equals(user) {
                    	…
        	} else {
                    	…
        	}
        	...
}  catch (SourceException е) {
    		…
}
class Source {
        	public User getUser(String login, String password) throws SourceException {
                    	...
                    	throw new SourceException(...);
                    	...
                    	return GUEST_USER;	//wrong login or password
                    	...
                    	return new User(...);
        	}
        	...
}
```
**Ответ.**  
```java
try {
/*альтернативный сценарий      
        ...
        	User user = source.getUser(login, password);
        	if(GUEST_USER.equals(user) {
                    	…
*/

/*основной сценарий       
        	} else {
                    	…
        	}
        	...
}  catch (SourceException е) {
    		…
}
 */
```  
Т.к. метод getUser() выкидывает checked исключение (SourceException - неверный логин и пароль), то вызывающий метод обязан обернуть
его в блок try-catch и предложить альтернативный сценарий - ввести верный логин и пароль.  

### 59. Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.
**Ответ.**  

### 60. Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.  
**Ответ.**  
Трансляция исключений – это когда вы перехватываете исключение более низкого уровня и оборачиваете его в исключение 
более высокого уровня, соответствующее абстракции, с которой вы имеете дело.    
Преобразование исключений обычно применяется, если исключения из сторонних библиотек не подходят для вашего приложения.    
Причинами этого могут быть:  
* Исключения, создаваемые библиотекой, имеют слишком низкий уровень, и/или вы не хотите, чтобы детали реализации попадали 
в другие части вашего приложения. Например, вы хотите использовать более универсальное исключение DataAccessException 
вместо SQLException более низкого уровня.  
* Библиотека использует проверенное исключение, в то время как вы предпочитаете использовать в своем приложении только 
исключение времени выполнения.  
```java
try {
        // code that can throw FooException
        } catch(FooException e) {
        // convert FooException to BarException
        throw new BarException(e);
        }
```
**Источник.** <https://dzone.com/articles/exception-translation-et>

### 61. Как можно избежать использования трансляций и зачем нужно это предпринимать?
**Ответ.**  

**Источник.** <>

### 62. В каких случаях надо предпочесть сцепление трансляции?  
**Ответ.**  

**Источник.** <>

### 63. Можно ли для исключительной ситуации определить, класс, который не является подклассом Exception, RuntimeException, Error.  
### Если да, то как он будет себя проявлять (как checked-exception или как unchecked-exception)?  
**Ответ.**  

**Источник.** <>

### 64. Обязательно ли информацию об исключительное ситуации представлять строковым полем?  
### Если нет, то какой альтернативный способ создания строкового представления исключения?  
**Ответ.**  

**Источник.** <>

### 65. Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?  
**Ответ.**  

**Источник.** <>

### 66. Приведите способы достижения атомарности по отношению к сбоям.  
**Ответ.**  

**Источник.** <>

### 67. Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.  
**Ответ.**  

**Источник.** <>

### 68. Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле src/in.csv.  
### Пример файла  
```
cool;75;90
clever;68;95
looser;30;48
```
### Является ли код, реализующий задание, антипаттерном? Обоснуйте ответ.  
```java
public class Runner {
        	public static void main(String[] args) {
                    	List<Trial> trials = new ArrayList<Trial>();
                    	try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
                               	while(sc.hasNext()) {
                                           	Trial trial = getTrial(sc);
                                           	trials.add(trial);
                               	}
                               	printTrials(trials);
                    	} catch (FileNotFoundException e) {
                               	System.out.println(Constants.ERROR_FILE_FOUND);
                    	}
        	}
        	private static Trial getTrial(Scanner sc) {
                    	String csvLine = sc.nextLine();
                    	String[] values = csvLine.split(Constants.DELIMETER);   	
                    	try {
                               	String name = values[Constants.NAME_INDEX];
                               	int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
                               	int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
                   		return new Trial(name, mark1, mark2);
                    	} catch (CsvLineException e) {
                               	System.out.println(Constants.ERROR_WRONG_DATA);
                    	}
        	}
```
**Ответ.**  

**Источник.** <>

### 69. Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного).
### Класс исключения содержит:  
* поле, которым является неправильная строка, считанная из файла (имя csvLine);  
* конструктор по умолчанию, вызывающий конструктор суперкласса;  
* параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;  
* параметризованный конструктор, принимающий строку с указанием причины исключения и неправильную строку, считанную из файла;  
* геттер с возвратом неправильной строки;  
* переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.
**Ответ.**  

**Источник.** <>

### 70. Необходимо создать метод для экспорта csv-файла в коллекцию.  
### При наличии хотя бы одной ошибки в исходных данных “отменить” создание коллекции.  
### Какие антипаттерны содержит следующий код?  
### Предложите варианты по избавлению от них.  
```java
private static List<Trial> getTrials(Scanner sc) {
List<Trial> trials = new ArrayList<Trial>();
try {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
} catch (CsvLineException e) {
System.err.println(e);
}
return trials;
}
```
**Ответ.**  

**Источник.** <>

### 72. Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров Trial.  
См. код ниже.
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
1. 	Файл не найден.
2. 	Ошибка в csv строке.
Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”
См. Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 370.
Считается, что классы для исключений созданы и имеют необходимый функционал.
Подсказка:
---
Надо использовать два исключения. Одно из которых будет нижнего уровня, другое верхнего уровня.
---
Еще одна подсказка:
---
Одно из исключений обрабатываемое, другое нет.
---
```java
//начало кода, реализующего задание
//---
interface TrialProvidable {
boolean hasTrial();
Trial getTrial();
}
 
public class TrialCsvImpl implements TrialProvidable {
private Scanner sc;
public CsvImpl(String csvName) {            	
sc = new Scanner(new FileReader(csvName));
}
public boolean hasTrial() {             	
return sc.hasNextLine();
}
public Trial getTrial() {
// get Trial instance from csv line
return trial;
}
}
 
public class Runner {
private static List<Trial> getTrials(TrialProvidable trialProvider) {
List<Trial> trials = new ArrayList<Trial>();
while(trialProvider.hasTrial()) {
Trial trial = trialProvider.getTrial();
trials.add(trial);
}
return trials;
}
 
public static void main(String[] args) {
TrialProvidable trialProvider = null;
try {
if("csv".equals(args[0])) {
trialProvider = new TrialCsvImpl("src/in.csv");
} else {
trialProvider = new TrialDBImpl();
}
List<Trial> trials = getTrials(trialProvider);
…
} finally {
if (trialProvider != null) {
trialProvider.close();
}
}
}
}
//---
//конец кода, реализующего задание
```
**Ответ.**  

**Источник.** <>
